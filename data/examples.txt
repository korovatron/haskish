=== Basic Functions ===
-- Simple function
double x = x * 2

-- Multiple parameters
add x y = x + y

-- Note: Haskish allows implicit multiplication (3x), but use explicit * for standard Haskell
triple x = 3 * x

-- Tests:
-- double 5  → 10
-- add 3 4   → 7
-- triple 6  → 18

=== Pattern Matching ===
-- Pattern match on specific values
factorial 0 = 1
factorial 1 = 1
factorial n = n * factorial (n - 1)

-- Pattern match with multiple cases
describe 0 = "zero"
describe 1 = "one"
describe n = "many"

-- Tests:
-- factorial 5  → 120
-- describe 0   → "zero"
-- describe 42  → "many"

=== Guards ===
-- Guards with otherwise
absolute n
  | n < 0     = -n
  | otherwise = n

-- Multiple guard conditions
classify n
  | n < 0     = "negative"
  | n == 0    = "zero"
  | n > 0     = "positive"

-- Guards with pattern matching
sign 0 = 0
sign n
  | n > 0     = 1
  | otherwise = -1

-- Tests:
-- absolute (-5)     → 5
-- classify (-3)     → "negative"
-- sign 42           → 1

=== if/then/else Expressions ===
-- Simple conditional (must have both then and else!)
abs n = if n < 0 then -n else n

-- if/then/else in expressions
doubleIfPositive n = if n > 0 then n * 2 else n

-- Nested if/then/else
classify n = if n < 0 then "negative" else if n == 0 then "zero" else "positive"

-- Comparison with guards (use guards for multiple conditions, if for simple binary choice)
-- Guards version:
signGuards n
  | n > 0     = 1
  | n == 0    = 0
  | otherwise = -1

-- if/then/else version:
signIf n = if n > 0 then 1 else if n == 0 then 0 else -1

-- if/then/else is an EXPRESSION (returns a value, can be used anywhere)
addOrSubtract x y flag = x + if flag then y else -y

-- Tests:
-- abs (-5)                    → 5
-- doubleIfPositive 10         → 20
-- doubleIfPositive (-3)       → -3
-- classify 42                 → "positive"
-- addOrSubtract 10 5 True     → 15
-- addOrSubtract 10 5 False    → 5

=== List Operations ===
-- Empty list and cons pattern
myLength [] = 0
myLength (x:xs) = 1 + myLength xs

-- Multiple elements
firstTwo (x:y:xs) = (x, y)

-- Specific patterns
sumTwo [x, y] = x + y

-- Cons operator
prependOne xs = 1:xs

-- Concatenation
joinLists xs ys = xs ++ ys

-- List indexing
thirdElement xs = xs !! 2

-- Range generation
oneToTen = [1..10]
evens = [2,4..20]

-- Tests:
-- myLength [1,2,3,4]          → 4
-- firstTwo [10,20,30]         → (10,20)
-- prependOne [2,3,4]          → [1,2,3,4]
-- joinLists [1,2] [3,4]       → [1,2,3,4]
-- thirdElement [10,20,30,40]  → 30
-- oneToTen                    → [1,2,3,4,5,6,7,8,9,10]

=== Recursion ===
-- Process all elements
doubleAll [] = []
doubleAll (x:xs) = (2*x) : doubleAll xs

-- Filter with recursion
positives [] = []
positives (x:xs)
  | x > 0     = x : positives xs
  | otherwise = positives xs

-- Fibonacci sequence (fast)
fibHelper 0 a b = a
fibHelper n a b = fibHelper (n-1) b (a+b)

fastFib n = fibHelper n 0 1

-- Tests:
-- doubleAll [1,2,3]      → [2,4,6]
-- positives [-1,2,-3,4]  → [2,4]
-- sumList [1,2,3,4]      → 10
-- fastFib                → 9227465

=== Higher-Order Functions ===
-- map examples
doubleMap xs = map (\x -> x * 2) xs
squareMap xs = map (\x -> x * x) xs

-- filter examples
bigNumbers xs = filter (\x -> x > 10) xs
evensOnly xs = filter (\x -> mod x 2 == 0) xs

-- fold examples
product xs = fold (\acc x -> acc * x) 1 xs
sumAll xs = fold (\acc x -> acc + x) 0 xs

-- Combining higher-order functions
sumOfSquares xs = fold (\acc x -> acc + x) 0 (map (\x -> x * x) xs)

-- Tests:
-- doubleMap [1,2,3]          → [2,4,6]
-- bigNumbers [5,15,3,20,8]   → [15,20]
-- evensOnly [1,2,3,4,5,6]    → [2,4,6]
-- product [1,2,3,4]          → 24
-- sumOfSquares [1,2,3]       → 14

=== Lambdas & Composition ===
-- Lambda with map
squareAll xs = map (\x -> x * x) xs

-- Lambda with filter
evensOnly xs = filter (\x -> mod x 2 == 0) xs

-- Lambda with fold
sumAll xs = fold (\acc x -> acc + x) 0 xs

-- Function Composition
addOne x = x + 1
timesTwo x = x * 2
addThenDouble = timesTwo . addOne

-- Multiple compositions
tripleCompose = (\x -> x + 1) . (\x -> x * 2) . (\x -> x - 3)

-- Partial Application (Currying)
multiply x y = x * y
timesTen = multiply 10

-- Operator sections
increment = (+1)
halve = (/2)
isPositive = (>0)

-- Tests:
-- squareAll [1,2,3,4]     → [1,4,9,16]
-- evensOnly [1,2,3,4,5,6] → [2,4,6]
-- addThenDouble 5         → 12
-- tripleCompose 10        → 15
-- timesTen 7              → 70
-- increment 5             → 6
-- halve 20                → 10

=== Church Numerals ===
-- Church encoding of numbers as higher-order functions
-- A Church numeral n is a function that applies f n times to x

-- Basic Church numerals
zero = \f -> \x -> x
one = \f -> \x -> f x
two = \f -> \x -> f (f x)
three = \f -> \x -> f (f (f x))

-- Church numeral operations
succ = \n -> \f -> \x -> f (n f x)
add = \m -> \n -> \f -> \x -> m f (n f x)
mul = \m -> \n -> \f -> m (n f)
pow = \m -> \n -> n m
pred = \n -> fst (n (\p -> pair (snd p) (succ (snd p))) (pair zero zero))
sub = \m -> \n -> n pred m

-- Convert Church numeral to integer
inc = \n -> n + 1

-- Boolean operations with Church encoding
true = \a -> \b -> a
false = \a -> \b -> b

-- Pair operations (using Church encoding)
pair = \a -> \b -> \f -> f a b
fst = \p -> p (\a -> \b -> a)
snd = \p -> p (\a -> \b -> b)

-- Tests:
-- three inc 0              → 3
-- (add two three) inc 0    → 5
-- (mul two three) inc 0    → 6
-- (pow two three) inc 0    → 8
-- (pred three) inc 0       → 2
-- (sub three two) inc 0    → 1
-- true 1 2                 → 1
-- false 1 2                → 2
-- fst (pair 10 20)         → 10
-- snd (pair 10 20)         → 20

=== Tuples ===
-- Tuple creation
point = (3, 5)
triple = (1, "hello", True)

-- Tuple pattern matching in functions
fst (x, y) = x
snd (x, y) = y

-- Tuple destructuring in assignments
(a, b) = (10, 20)
((x, y), z) = ((1, 2), 3)

-- Stateful computation with tuples and lambdas
counter n = \_ -> (n, counter (n + 1))
-- Usage: c0 = counter 0
--        (step0, c1) = c0 ()
--        (step1, c2) = c1 ()

-- Tuples with guards
distance (x1, y1) (x2, y2) = ((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1))

-- Compare tuples
comparePoints (x1, y1) (x2, y2)
  | x1 > x2 && y1 > y2 = "first dominates"
  | x1 < x2 && y1 < y2 = "second dominates"
  | x1 == x2 && y1 == y2 = "equal"
  | otherwise = "incomparable"

-- Nested tuples
nested = ((1, 2), (3, 4))

-- Lists of tuples
points = [(0,0), (1,1), (2,4)]

-- Tuples of lists
segments = ([1,2,3], [4,5,6])

-- Tuple processing
sumPairs [] = []
sumPairs ((x,y):rest) = (x+y) : sumPairs rest

-- Tests:
-- point                       → (3,5)
-- fst (10,20)                 → 10
-- comparePoints (5,3) (2,1)   → "first dominates"
-- points                      → [(0,0),(1,1),(2,4)]
-- sumPairs [(1,2),(3,4),(5,6)] → [3,7,11]

=== Sorting Algorithms ===
-- Bubble Sort
bubblePass [] = []
bubblePass [x] = [x]
bubblePass (x:y:xs)
  | x > y = y : bubblePass (x:xs)
  | otherwise = x : bubblePass (y:xs)

bubbleSortN 0 xs = xs
bubbleSortN n xs = bubbleSortN (n - 1) (bubblePass xs)

bubbleSort xs = bubbleSortN (length xs) xs

-- QuickSort (note: without where clauses, using helper)
qsort [] = []
qsort (x:xs) = qsort (filter (\y -> y <= x) xs) ++ [x] ++ qsort (filter (\y -> y > x) xs)

-- Merge two sorted lists
merge [] ys = ys
merge xs [] = xs
merge (x:xs) (y:ys)
  | x <= y = x : merge xs (y:ys)
  | otherwise = y : merge (x:xs) ys

-- Tests:
-- bubbleSort [5,2,8,1,9]      → [1,2,5,8,9]
-- bubbleSort [23,56,32,1,-56] → [-56,1,23,32,56]
-- qsort [3,1,4,1,5,9,2,6]     → [1,1,2,3,4,5,6,9]
-- merge [1,3,5] [2,4,6]       → [1,2,3,4,5,6]

=== Prime Numbers ===
-- Check if n is divisible by any number from d to sqrt(n)
isDivisibleBy n d
  | d * d > n = False
  | mod n d == 0 = True
  | otherwise = isDivisibleBy n (d + 1)

-- Prime test
isPrime n
  | n < 2 = False
  | n == 2 = True
  | mod n 2 == 0 = False
  | otherwise = not (isDivisibleBy n 3)

-- Prime factorization (returns list of prime factors)
primeFactors 1 = []
primeFactors n = factorHelper n 2

factorHelper 1 d = []
factorHelper n d
  | d * d > n = [n]
  | mod n d == 0 = d : factorHelper (div n d) d
  | otherwise = factorHelper n (d + 1)

-- Sieve of Eratosthenes (primes up to n)
sieve [] = []
sieve (x:xs) = x : sieve (filter (\n -> mod n x /= 0) xs)

primesUpTo n = sieve [2..n]

-- Tests:
-- isPrime 17                             → True
-- isPrime 100                            → False
-- primeFactors 60                        → [2,2,3,5]
-- primeFactors 17                        → [17]
-- primesUpTo 30                          → [2,3,5,7,11,13,17,19,23,29]
-- map isPrime [2,3,4,5,6,7,8,9,10,11]    → [True,True,False,True,False,True,False,False,False,True]

=== List Utilities ===
-- Remove duplicates from a list
elem x [] = False
elem x (y:ys)
  | x == y = True
  | otherwise = elem x ys

nub [] = []
nub (x:xs)
  | elem x xs = nub xs
  | otherwise = x : nub xs

-- Fixed-point iteration
fixedPoint f x
  | x == f x = x
  | otherwise = fixedPoint f (f x)

-- Digital root (repeatedly sum digits until single digit)
sumDigits 0 = 0
sumDigits n = mod n 10 + sumDigits (div n 10)

digitalRoot n = fixedPoint sumDigits n

-- Reverse using fold
reverseList xs = fold (\acc x -> x : acc) [] xs

-- Maximum element
maxList [x] = x
maxList (x:xs)
  | x > maxList xs = x
  | otherwise = maxList xs

-- Tests:
-- nub [1,2,3,2,4,1,5]                → [3,2,4,1,5]
-- nub [[1,2], [3,4], [1,2], [5,6]]   → [[3,4],[1,2],[5,6]]
-- digitalRoot 38                     → 2
-- digitalRoot 123                    → 6
-- reverseList [1,2,3,4]              → [4,3,2,1]
-- maxList [3,7,2,9,1]                → 9

=== Built-in Functions ===
-- head and tail
getFirst xs = head xs
getRest xs = tail xs

-- length and null
isEmpty xs = null xs
count xs = length xs

-- reverse
backwards xs = reverse xs

-- take and drop
firstThree xs = take 3 xs
skipTwo xs = drop 2 xs

-- Combining built-ins
getMiddle xs = drop 1 (take (length xs - 1) xs)

-- Using built-ins with operators
lastElement xs = head (reverse xs)
allButLast xs = reverse (tail (reverse xs))

-- Tests:
-- getFirst [1,2,3]          → 1
-- getRest [1,2,3]           → [2,3]
-- isEmpty []                → True
-- backwards [1,2,3]         → [3,2,1]
-- firstThree [1,2,3,4,5]    → [1,2,3]
-- getMiddle [1,2,3,4,5]     → [2,3,4]
-- lastElement [1,2,3,4,5]   → 5
-- allButLast [1,2,3,4,5]    → [1,2,3,4]

=== Trigonometry ===
factorial 0 = 1
factorial n = n * factorial (n - 1)

power x 0 = 1
power x n = x * power x (n - 1)

pi = 3.141592654

abs x
  | x < 0  = -x
  | x >= 0 = x

-- sign: 1, -1, 1, -1, ...
sign n
  | mod n 2 == 0 = 1
  | otherwise = -1

-- nth term of Taylor series for sin(x)
sinTerm x n = sign n * power x (2*n + 1) / factorial (2*n + 1)

sinHelper x n acc
  | abs (sinTerm x n) < 1e-12 = acc
  | otherwise = sinHelper x (n + 1) (acc + sinTerm x n)

mySin x = sinHelper x 0 0

-- nth term of Taylor series for cos(x)
cosTerm x n = sign n * power x (2*n) / factorial (2*n)

cosHelper x n acc
  | abs (cosTerm x n) < 1e-12 = acc
  | otherwise = cosHelper x (n + 1) (acc + cosTerm x n)

myCos x = cosHelper x 0 0

myTan x = (mySin x) / (myCos x)

-- try mySin (pi/6) etc

=== String Processing - RLE Compression ===
-- Run-Length Encoding: compress strings by counting consecutive characters

-- Main RLE function
rle [] = []
rle (x:xs) = rleHelper x 1 xs

-- Helper accumulates count for each character
rleHelper current count [] = [(current, count)]
rleHelper current count (y:ys)
  | current == y = rleHelper current (count + 1) ys
  | otherwise = (current, count) : rleHelper y 1 ys

-- Replicate a character n times
replicate 0 c = []
replicate n c = c : replicate (n - 1) c

-- Decode RLE back to original string
unrle [] = []
unrle ((c, n):rest) = replicate n c ++ unrle rest

-- Tests:
-- rle "AABBBBBCCDD"           → [("A",2),("B",5),("C",2),("D",2)]
-- rle "WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWB"
--   → [("W",12),("B",1),("W",12),("B",3),("W",24),("B",1)]
-- unrle [("A",2),("B",5),("C",2),("D",2)]
--   → ["A","A","B","B","B","B","B","C","C","D","D"]
-- unrle (rle "Hello")         → ["H","e","l","l","o"]

=== Luhn Algorithm - Credit Card Validation ===
-- The real algorithm used by credit card companies!
-- Validates card numbers using checksum

-- Convert string of digits to list of integers
toDigits [] = []
toDigits (x:xs) = (ord x - ord '0') : toDigits xs

-- Double a digit, subtract 9 if result > 9
doubleDigit n = if n * 2 > 9 then n * 2 - 9 else n * 2

-- Double every other digit from the right (use reverse!)
doubleEveryOther [] = []
doubleEveryOther [x] = [x]
doubleEveryOther (x:y:rest) = x : doubleDigit y : doubleEveryOther rest

-- Sum all digits in a list
sumDigits [] = 0
sumDigits (x:xs) = x + sumDigits xs

-- Main Luhn validation function (inline composition)
luhn cardNumber = mod (sumDigits (doubleEveryOther (reverse (toDigits cardNumber)))) 10 == 0

-- Luhn check on a list of digits directly
luhnDigits digits = mod (sumDigits (doubleEveryOther (reverse digits))) 10 == 0

-- Tests (these are valid test card numbers):
-- luhn "4532015112830366"     → True   (Valid Visa)
-- luhn "6011514433546201"     → True   (Valid Discover)
-- luhn "378282246310005"      → True   (Valid Amex)
-- luhn "1234567812345670"     → True   (Valid test number)
-- luhn "1234567812345678"     → False  (Invalid checksum)
-- luhn "0000000000000000"     → True   (Edge case)
-- luhnDigits [4,5,3,2,0,1,5,1,1,2,8,3,0,3,6,6]  → True

-- Show the step-by-step process:
-- toDigits "4532"                          → [4,5,3,2]
-- reverse [4,5,3,2]                        → [2,3,5,4]
-- doubleEveryOther [2,3,5,4]               → [2,6,5,8]
-- sumDigits [2,6,5,8]                      → 21