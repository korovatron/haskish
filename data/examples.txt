=== Basic Functions ===
-- Simple function
double x = x * 2

-- Multiple parameters
add x y = x + y

-- Note: Haskish allows implicit multiplication (3x), but use explicit * for standard Haskell
triple x = 3 * x

-- Tests:
-- double 5  → 10
-- add 3 4   → 7
-- triple 6  → 18

=== Pattern Matching ===
-- Pattern match on specific values
factorial 0 = 1
factorial 1 = 1
factorial n = n * factorial (n - 1)

-- Pattern match with multiple cases
describe 0 = "zero"
describe 1 = "one"
describe n = "many"

-- Tests:
-- factorial 5  → 120
-- describe 0   → "zero"
-- describe 42  → "many"

=== Guards ===
-- Guards with otherwise
absolute n
  | n < 0     = -n
  | otherwise = n

-- Multiple guard conditions
classify n
  | n < 0     = "negative"
  | n == 0    = "zero"
  | n > 0     = "positive"

-- Guards with pattern matching
sign 0 = 0
sign n
  | n > 0     = 1
  | otherwise = -1

-- Tests:
-- absolute (-5)     → 5
-- classify (-3)     → "negative"
-- sign 42           → 1

=== if/then/else Expressions ===
-- Simple conditional (must have both then and else!)
abs n = if n < 0 then -n else n

-- if/then/else in expressions
doubleIfPositive n = if n > 0 then n * 2 else n

-- Nested if/then/else
classify n = if n < 0 then "negative" else if n == 0 then "zero" else "positive"

-- Comparison with guards (use guards for multiple conditions, if for simple binary choice)
-- Guards version:
signGuards n
  | n > 0     = 1
  | n == 0    = 0
  | otherwise = -1

-- if/then/else version:
signIf n = if n > 0 then 1 else if n == 0 then 0 else -1

-- if/then/else is an EXPRESSION (returns a value, can be used anywhere)
addOrSubtract x y flag = x + if flag then y else -y

-- Tests:
-- abs (-5)                    → 5
-- doubleIfPositive 10         → 20
-- doubleIfPositive (-3)       → -3
-- classify 42                 → "positive"
-- addOrSubtract 10 5 True     → 15
-- addOrSubtract 10 5 False    → 5

=== List Operations ===
-- Empty list and cons pattern
myLength [] = 0
myLength (x:xs) = 1 + myLength xs

-- Multiple elements
firstTwo (x:y:xs) = (x, y)

-- Specific patterns
sumTwo [x, y] = x + y

-- Cons operator
prependOne xs = 1:xs

-- Concatenation
joinLists xs ys = xs ++ ys

-- List indexing
thirdElement xs = xs !! 2

-- Range generation
oneToTen = [1..10]
evens = [2,4..20]

-- Tests:
-- myLength [1,2,3,4]          → 4
-- firstTwo [10,20,30]         → (10,20)
-- prependOne [2,3,4]          → [1,2,3,4]
-- joinLists [1,2] [3,4]       → [1,2,3,4]
-- thirdElement [10,20,30,40]  → 30
-- oneToTen                    → [1,2,3,4,5,6,7,8,9,10]

=== Recursion ===
-- Process all elements
doubleAll [] = []
doubleAll (x:xs) = (2*x) : doubleAll xs

-- Filter with recursion
positives [] = []
positives (x:xs)
  | x > 0     = x : positives xs
  | otherwise = positives xs

-- Fibonacci sequence (fast)
fibHelper 0 a b = a
fibHelper n a b = fibHelper (n-1) b (a+b)

fastFib n = fibHelper n 0 1

-- Tests:
-- doubleAll [1,2,3]      → [2,4,6]
-- positives [-1,2,-3,4]  → [2,4]
-- sumList [1,2,3,4]      → 10
-- fastFib                → 9227465

=== Higher-Order Functions ===
-- map examples
doubleMap xs = map (\x -> x * 2) xs
squareMap xs = map (\x -> x * x) xs

-- filter examples
bigNumbers xs = filter (\x -> x > 10) xs
evensOnly xs = filter (\x -> mod x 2 == 0) xs

-- fold examples
product xs = fold (\acc x -> acc * x) 1 xs
sumAll xs = fold (\acc x -> acc + x) 0 xs

-- Combining higher-order functions
sumOfSquares xs = fold (\acc x -> acc + x) 0 (map (\x -> x * x) xs)

-- Tests:
-- doubleMap [1,2,3]          → [2,4,6]
-- bigNumbers [5,15,3,20,8]   → [15,20]
-- evensOnly [1,2,3,4,5,6]    → [2,4,6]
-- product [1,2,3,4]          → 24
-- sumOfSquares [1,2,3]       → 14

=== Lambdas & Composition ===
-- Lambda with map
squareAll xs = map (\x -> x * x) xs

-- Lambda with filter
evensOnly xs = filter (\x -> mod x 2 == 0) xs

-- Lambda with fold
sumAll xs = fold (\acc x -> acc + x) 0 xs

-- Function Composition
addOne x = x + 1
timesTwo x = x * 2
addThenDouble = timesTwo . addOne

-- Multiple compositions
tripleCompose = (\x -> x + 1) . (\x -> x * 2) . (\x -> x - 3)

-- Partial Application (Currying)
multiply x y = x * y
timesTen = multiply 10

-- Operator sections
increment = (+1)
halve = (/2)
isPositive = (>0)

-- Tests:
-- squareAll [1,2,3,4]     → [1,4,9,16]
-- evensOnly [1,2,3,4,5,6] → [2,4,6]
-- addThenDouble 5         → 12
-- tripleCompose 10        → 15
-- timesTen 7              → 70
-- increment 5             → 6
-- halve 20                → 10

=== Church Numerals ===
-- Church encoding of numbers as higher-order functions
-- A Church numeral n is a function that applies f n times to x

-- Basic Church numerals
zero = \f -> \x -> x
one = \f -> \x -> f x
two = \f -> \x -> f (f x)
three = \f -> \x -> f (f (f x))

-- Church numeral operations
succ = \n -> \f -> \x -> f (n f x)
add = \m -> \n -> \f -> \x -> m f (n f x)
mul = \m -> \n -> \f -> m (n f)
pow = \m -> \n -> n m
pred = \n -> fst (n (\p -> pair (snd p) (succ (snd p))) (pair zero zero))
sub = \m -> \n -> n pred m

-- Convert Church numeral to integer
inc = \n -> n + 1

-- Boolean operations with Church encoding
true = \a -> \b -> a
false = \a -> \b -> b

-- Pair operations (using Church encoding)
pair = \a -> \b -> \f -> f a b
fst = \p -> p (\a -> \b -> a)
snd = \p -> p (\a -> \b -> b)

-- Tests:
-- three inc 0              → 3
-- (add two three) inc 0    → 5
-- (mul two three) inc 0    → 6
-- (pow two three) inc 0    → 8
-- (pred three) inc 0       → 2
-- (sub three two) inc 0    → 1
-- true 1 2                 → 1
-- false 1 2                → 2
-- fst (pair 10 20)         → 10
-- snd (pair 10 20)         → 20

=== Tuples ===
-- Tuple creation
point = (3, 5)
triple = (1, "hello", True)

-- Tuple pattern matching in functions
fst (x, y) = x
snd (x, y) = y

-- Tuple destructuring in assignments
(a, b) = (10, 20)
((x, y), z) = ((1, 2), 3)

-- Stateful computation with tuples and lambdas
counter n = \_ -> (n, counter (n + 1))
-- Usage: c0 = counter 0
--        (step0, c1) = c0 ()
--        (step1, c2) = c1 ()

-- Tuples with guards
distance (x1, y1) (x2, y2) = ((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1))

-- Compare tuples
comparePoints (x1, y1) (x2, y2)
  | x1 > x2 && y1 > y2 = "first dominates"
  | x1 < x2 && y1 < y2 = "second dominates"
  | x1 == x2 && y1 == y2 = "equal"
  | otherwise = "incomparable"

-- Nested tuples
nested = ((1, 2), (3, 4))

-- Lists of tuples
points = [(0,0), (1,1), (2,4)]

-- Tuples of lists
segments = ([1,2,3], [4,5,6])

-- Tuple processing
sumPairs [] = []
sumPairs ((x,y):rest) = (x+y) : sumPairs rest

-- Tests:
-- point                       → (3,5)
-- fst (10,20)                 → 10
-- comparePoints (5,3) (2,1)   → "first dominates"
-- points                      → [(0,0),(1,1),(2,4)]
-- sumPairs [(1,2),(3,4),(5,6)] → [3,7,11]

=== Sorting Algorithms ===
-- Bubble Sort
bubblePass [] = []
bubblePass [x] = [x]
bubblePass (x:y:xs)
  | x > y = y : bubblePass (x:xs)
  | otherwise = x : bubblePass (y:xs)

bubbleSortN 0 xs = xs
bubbleSortN n xs = bubbleSortN (n - 1) (bubblePass xs)

bubbleSort xs = bubbleSortN (length xs) xs

-- QuickSort (note: without where clauses, using helper)
qsort [] = []
qsort (x:xs) = qsort (filter (\y -> y <= x) xs) ++ [x] ++ qsort (filter (\y -> y > x) xs)

-- Merge two sorted lists
merge [] ys = ys
merge xs [] = xs
merge (x:xs) (y:ys)
  | x <= y = x : merge xs (y:ys)
  | otherwise = y : merge (x:xs) ys

-- Tests:
-- bubbleSort [5,2,8,1,9]      → [1,2,5,8,9]
-- bubbleSort [23,56,32,1,-56] → [-56,1,23,32,56]
-- qsort [3,1,4,1,5,9,2,6]     → [1,1,2,3,4,5,6,9]
-- merge [1,3,5] [2,4,6]       → [1,2,3,4,5,6]

=== Prime Numbers ===
-- Check if n is divisible by any number from d to sqrt(n)
isDivisibleBy n d
  | d * d > n = False
  | mod n d == 0 = True
  | otherwise = isDivisibleBy n (d + 1)

-- Prime test
isPrime n
  | n < 2 = False
  | n == 2 = True
  | mod n 2 == 0 = False
  | otherwise = not (isDivisibleBy n 3)

-- Prime factorization (returns list of prime factors)
primeFactors 1 = []
primeFactors n = factorHelper n 2

factorHelper 1 d = []
factorHelper n d
  | d * d > n = [n]
  | mod n d == 0 = d : factorHelper (div n d) d
  | otherwise = factorHelper n (d + 1)

-- Sieve of Eratosthenes (primes up to n)
sieve [] = []
sieve (x:xs) = x : sieve (filter (\n -> mod n x /= 0) xs)

primesUpTo n = sieve [2..n]

-- Tests:
-- isPrime 17                             → True
-- isPrime 100                            → False
-- primeFactors 60                        → [2,2,3,5]
-- primeFactors 17                        → [17]
-- primesUpTo 30                          → [2,3,5,7,11,13,17,19,23,29]
-- map isPrime [2,3,4,5,6,7,8,9,10,11]    → [True,True,False,True,False,True,False,False,False,True]

=== List Utilities ===
-- Remove duplicates from a list
elem x [] = False
elem x (y:ys)
  | x == y = True
  | otherwise = elem x ys

nub [] = []
nub (x:xs)
  | elem x xs = nub xs
  | otherwise = x : nub xs

-- Fixed-point iteration
fixedPoint f x
  | x == f x = x
  | otherwise = fixedPoint f (f x)

-- Digital root (repeatedly sum digits until single digit)
sumDigits 0 = 0
sumDigits n = mod n 10 + sumDigits (div n 10)

digitalRoot n = fixedPoint sumDigits n

-- Reverse using fold
reverseList xs = fold (\acc x -> x : acc) [] xs

-- Maximum element
maxList [x] = x
maxList (x:xs)
  | x > maxList xs = x
  | otherwise = maxList xs

-- Tests:
-- nub [1,2,3,2,4,1,5]                → [3,2,4,1,5]
-- nub [[1,2], [3,4], [1,2], [5,6]]   → [[3,4],[1,2],[5,6]]
-- digitalRoot 38                     → 2
-- digitalRoot 123                    → 6
-- reverseList [1,2,3,4]              → [4,3,2,1]
-- maxList [3,7,2,9,1]                → 9

=== Built-in Functions ===
-- head and tail
getFirst xs = head xs
getRest xs = tail xs

-- length and null
isEmpty xs = null xs
count xs = length xs

-- reverse
backwards xs = reverse xs

-- take and drop
firstThree xs = take 3 xs
skipTwo xs = drop 2 xs

-- Combining built-ins
getMiddle xs = drop 1 (take (length xs - 1) xs)

-- Using built-ins with operators
lastElement xs = head (reverse xs)
allButLast xs = reverse (tail (reverse xs))

-- Tests:
-- getFirst [1,2,3]          → 1
-- getRest [1,2,3]           → [2,3]
-- isEmpty []                → True
-- backwards [1,2,3]         → [3,2,1]
-- firstThree [1,2,3,4,5]    → [1,2,3]
-- getMiddle [1,2,3,4,5]     → [2,3,4]
-- lastElement [1,2,3,4,5]   → 5
-- allButLast [1,2,3,4,5]    → [1,2,3,4]

=== Trigonometry ===
factorial 0 = 1
factorial n = n * factorial (n - 1)

power x 0 = 1
power x n = x * power x (n - 1)

pi = 3.141592654

abs x
  | x < 0  = -x
  | x >= 0 = x

-- sign: 1, -1, 1, -1, ...
sign n
  | mod n 2 == 0 = 1
  | otherwise = -1

-- nth term of Taylor series for sin(x)
sinTerm x n = sign n * power x (2*n + 1) / factorial (2*n + 1)

sinHelper x n acc
  | abs (sinTerm x n) < 1e-12 = acc
  | otherwise = sinHelper x (n + 1) (acc + sinTerm x n)

mySin x = sinHelper x 0 0

-- nth term of Taylor series for cos(x)
cosTerm x n = sign n * power x (2*n) / factorial (2*n)

cosHelper x n acc
  | abs (cosTerm x n) < 1e-12 = acc
  | otherwise = cosHelper x (n + 1) (acc + cosTerm x n)

myCos x = cosHelper x 0 0

myTan x = (mySin x) / (myCos x)

-- try mySin (pi/6) etc

=== String Processing - RLE Compression ===
-- Run-Length Encoding: compress strings by counting consecutive characters

-- Main RLE function
rle [] = []
rle (x:xs) = rleHelper x 1 xs

-- Helper accumulates count for each character
rleHelper current count [] = [(current, count)]
rleHelper current count (y:ys)
  | current == y = rleHelper current (count + 1) ys
  | otherwise = (current, count) : rleHelper y 1 ys

-- Replicate a character n times
replicate 0 c = []
replicate n c = c : replicate (n - 1) c

-- Decode RLE back to original string
unrle [] = []
unrle ((c, n):rest) = replicate n c ++ unrle rest

-- Tests:
-- rle "AABBBBBCCDD"           → [('A',2),('B',5),('C',2),('D',2)]
-- rle "WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWB"
--   → [('W',12),('B',1),('W',12),('B',3),('W',24),('B',1)]
-- unrle [('A',2),('B',5),('C',2),('D',2)]
--   → "AABBBBBCCDD"
-- unrle (rle "Hello")         → "Hello"

=== Luhn Algorithm - Credit Card Validation ===
-- The real algorithm used by credit card companies!
-- Validates card numbers using checksum

-- Convert string of digits to list of integers
toDigits [] = []
toDigits (x:xs) = (ord x - ord '0') : toDigits xs

-- Double a digit, subtract 9 if result > 9
doubleDigit n = if n * 2 > 9 then n * 2 - 9 else n * 2

-- Double every other digit from the right (use reverse!)
doubleEveryOther [] = []
doubleEveryOther [x] = [x]
doubleEveryOther (x:y:rest) = x : doubleDigit y : doubleEveryOther rest

-- Sum all digits in a list
sumDigits [] = 0
sumDigits (x:xs) = x + sumDigits xs

-- Main Luhn validation function (inline composition)
luhn cardNumber = mod (sumDigits (doubleEveryOther (reverse (toDigits cardNumber)))) 10 == 0

-- Luhn check on a list of digits directly
luhnDigits digits = mod (sumDigits (doubleEveryOther (reverse digits))) 10 == 0

-- Tests (these are valid test card numbers):
-- luhn "4532015112830366"     → True   (Valid Visa)
-- luhn "6011514433546201"     → True   (Valid Discover)
-- luhn "378282246310005"      → True   (Valid Amex)
-- luhn "1234567812345670"     → True   (Valid test number)
-- luhn "1234567812345678"     → False  (Invalid checksum)
-- luhn "0000000000000000"     → True   (Edge case)
-- luhnDigits [4,5,3,2,0,1,5,1,1,2,8,3,0,3,6,6]  → True

-- Show the step-by-step process:
-- toDigits "4532"                          → [4,5,3,2]
-- reverse [4,5,3,2]                        → [2,3,5,4]
-- doubleEveryOther [2,3,5,4]               → [2,6,5,8]
-- sumDigits [2,6,5,8]                      → 21

=== Dictionary Compression ===
-- Compress text by replacing frequent words with numeric codes
-- This demonstrates frequency analysis and substitution compression

-- Helper to check if string is empty after dropping spaces
allSpaces [] = True
allSpaces s
  | head s == ' ' = allSpaces (tail s)
  | otherwise     = False

-- Split string into words (splits on spaces)
words [] = []
words s
  | allSpaces s = []
  | otherwise   = wordsHelper (dropSpaces s)

wordsHelper [] = []
wordsHelper s = takeWord s : words (dropWord s)

takeWord [] = []
takeWord s
  | head s == ' ' = []
  | otherwise     = head s : takeWord (tail s)

dropWord [] = []
dropWord s
  | head s == ' ' = tail s
  | otherwise     = dropWord (tail s)

dropSpaces [] = []
dropSpaces s
  | head s == ' ' = dropSpaces (tail s)
  | otherwise     = s

-- Count occurrences of a word in a list
countWord target [] = 0
countWord target (x:xs)
  | target == x = 1 + countWord target xs
  | otherwise   = countWord target xs

-- Remove duplicates from list
unique [] = []
unique (x:xs) = x : unique (removeAll x xs)

removeAll ee [] = []
removeAll ee (x:xs)
  | ee == x   = removeAll ee xs
  | otherwise = x : removeAll ee xs

-- Build frequency list: [(word, count)]
freqs ws = map (\zz -> (zz, countWord zz ws)) (unique ws)

-- Get first and second elements of tuple
fst (aa,bb) = aa
snd (aa,bb) = bb

-- Get top N most frequent words
topN nn [] = []
topN 0 fs = []
topN nn fs = maxFreq fs : topN (nn - 1) (removeAll (maxFreq fs) fs)

maxFreq [] = ("", 0)
maxFreq (pair:rest)
  | null rest = pair
  | snd pair >= snd (maxFreq rest) = pair
  | otherwise = maxFreq rest

-- Build dictionary from text (top 10 words)
buildDict txt = filter notEmpty (topN 10 (freqs (words txt)))

notEmpty pair = not (null (fst pair))

-- Compress: return list of numeric codes
compress txt = compressWords (buildDict txt) (words txt)

compressWords dict [] = []
compressWords dict (ww:wws) = codeFor dict ww 0 : compressWords dict wws

codeFor [] ww nn = nn
codeFor (pair:pairs) ww nn
  | ww == fst pair = nn
  | otherwise      = codeFor pairs ww (nn + 1)

-- Tests:
-- compress "the cat sat on the mat"
-- → [0,1,2,3,0,4]
-- The most frequent word "the" gets code 0

-- compress "the cat sat on the mat the dog sat on the log"
-- → [0,3,1,2,0,4,0,5,1,2,0,6]
-- "the" (4×) = 0, "sat" (2×) = 1, "on" (2×) = 2, others get higher codes

=== Newton's Method - Square Root ===
-- Compute square root using Newton's method
-- Iteratively improves guess until close enough

-- Helper: absolute value
abs n
  | n < 0     = -n
  | otherwise = n

-- Square root function
sqrt n
  | n < 0     = error "Cannot compute square root of negative number"
  | n == 0    = 0
  | otherwise = sqrtHelper n 1.0

sqrtHelper n guess
  | abs (guess * guess - n) < 0.0001 = guess
  | otherwise                         = sqrtHelper n ((guess + n / guess) / 2)

-- Tests:
-- sqrt 16     → 4.0
-- sqrt 25     → 5.0
-- sqrt 2      → 1.414...
-- sqrt 100    → 10.0

=== Polynomial Calculus - Differentiation & Integration ===
-- Polynomials represented as lists of coefficients [a0, a1, a2, ...]
-- For polynomial: a0 + a1*x + a2*x^2 + a3*x^3 + ...
-- Example: [3, -5, 0, 2] represents 3 - 5x + 2x³

-- Evaluate polynomial at a given x value
-- Uses Horner's method for efficiency: a0 + x*(a1 + x*(a2 + x*a3))
evalPoly [] x = 0
evalPoly coeffs x = evalPolyHelper 0 (reverse coeffs) x

evalPolyHelper acc [] x = acc
evalPolyHelper acc (c:cs) x = evalPolyHelper (acc * x + c) cs x

-- Differentiate polynomial using power rule: d/dx(ax^n) = n*a*x^(n-1)
polyDerivative [] = []
polyDerivative [a] = [0]
polyDerivative (a:rest) = polyDerivHelper rest 1

polyDerivHelper [] n = []
polyDerivHelper (c:cs) n = (n * c) : polyDerivHelper cs (n + 1)

-- Integrate polynomial: ∫(ax^n)dx = a/(n+1) * x^(n+1) + C
-- Constant of integration C is assumed to be 0
polyIntegral coeffs = 0 : polyIntegralHelper coeffs 0

polyIntegralHelper [] n = []
polyIntegralHelper (c:cs) n = (c / (n + 1)) : polyIntegralHelper cs (n + 1)

-- Add two polynomials
polyAdd [] ys = ys
polyAdd xs [] = xs
polyAdd (x:xs) (y:ys) = (x + y) : polyAdd xs ys

-- Multiply polynomial by a constant
polyScale k [] = []
polyScale k (c:cs) = (k * c) : polyScale k cs

-- Multiply two polynomials
polyMult [] ys = []
polyMult (x:xs) ys = polyAdd (polyScale x ys) (0 : polyMult xs ys)

-- Remove leading zeros from polynomial
polyTrim [] = []
polyTrim cs = polyTrimHelper (reverse cs)

polyTrimHelper [] = []
polyTrimHelper (c:cs)
  | c == 0    = polyTrimHelper cs
  | otherwise = reverse (c:cs)

-- Degree of polynomial (highest power with non-zero coefficient)
polyDegree [] = 0
polyDegree cs = length (polyTrim cs) - 1

-- Apply derivative n times
polyDerivativeN 0 poly = poly
polyDerivativeN n poly = polyDerivativeN (n - 1) (polyDerivative poly)

-- Tests:
-- Polynomial: 3 + 2x + x² is represented as [3, 2, 1]
-- evalPoly [3, 2, 1] 2                      → 11  (3 + 2*2 + 2² = 11)
-- evalPoly [1, 0, 1] 3                      → 10  (1 + 3² = 10)

-- Derivative: d/dx(3 + 2x + x²) = 2 + 2x
-- polyDerivative [3, 2, 1]                  → [2, 2]

-- Polynomial: 5 - 6x + 3x² - 2x³ is [5, -6, 3, -2]
-- polyDerivative [5, -6, 3, -2]             → [-6, 6, -6]  (which is -6 + 6x - 6x²)

-- Second derivative: d²/dx²(x⁴) = 12x²
-- polyDerivativeN 2 [0, 0, 0, 0, 1]         → [0, 0, 12]

-- Integral: ∫(2 + 2x)dx = 2x + x² (+ C)
-- polyIntegral [2, 2]                       → [0, 2, 1]

-- Integral: ∫(6x² - 6x)dx = 2x³ - 3x²
-- polyIntegral [0, -6, 6]                   → [0, 0, -3, 2]

-- Add: (3 + 2x) + (1 + x) = 4 + 3x
-- polyAdd [3, 2] [1, 1]                     → [4, 3]

-- Multiply: (1 + x) * (1 + x) = 1 + 2x + x²
-- polyMult [1, 1] [1, 1]                    → [1, 2, 1]

-- Multiply: (2 + x) * (3 - x) = 6 + x - x²
-- polyMult [2, 1] [3, -1]                   → [6, 1, -1]

-- Fundamental Theorem of Calculus check:
-- If P'(x) = p(x), then integrating p(x) gives P(x)
-- Start with [3, 2, 1] (3 + 2x + x²)
-- polyIntegral (polyDerivative [3, 2, 1])   → [0, 2, 1]  (differs by constant!)

-- Degree examples:
-- polyDegree [1, 2, 3]                      → 2  (polynomial is degree 2)
-- polyDegree [5]                            → 0  (constant)
-- polyDegree [1, 0, 0, 0, 2]                → 4  (degree 4)

=== Sudoku Validator ===
-- Validate a Sudoku board (9x9 grid)
-- Board is a list of 9 rows, each row is a list of 9 numbers (1-9)

-- Check if element is in list
contains e [] = False
contains e (x:xs)
  | e == x    = True
  | otherwise = contains e xs

-- Check if a group has no duplicates and all values 1-9
isValidGroup [] = True
isValidGroup (x:xs)
  | x < 1 || x > 9 = False
  | contains x xs  = False
  | otherwise      = isValidGroup xs

-- Get column n from the board
getColumn n board = [row !! n | row <- board]

-- Get all 9 columns
getColumns board = [getColumn i board | i <- [0..8]]

-- Get a 3x3 box starting at row r, column c
getBox r c board = [board !! (r+i) !! (c+j) | i <- [0..2], j <- [0..2]]

-- Get all 9 boxes
getBoxes board = [getBox r c board | r <- [0,3,6], c <- [0,3,6]]

-- Check if all groups in a list are valid
allValid [] = True
allValid (g:gs) = isValidGroup g && allValid gs

-- Main validation function
validSudoku board = allValid board && allValid (getColumns board) && allValid (getBoxes board)

-- Example board (valid)
board = [[5,3,4,6,7,8,9,1,2],
         [6,7,2,1,9,5,3,4,8],
         [1,9,8,3,4,2,5,6,7],
         [8,5,9,7,6,1,4,2,3],
         [4,2,6,8,5,3,7,9,1],
         [7,1,3,9,2,4,8,5,6],
         [9,6,1,5,3,7,2,8,4],
         [2,8,7,4,1,9,6,3,5],
         [3,4,5,2,8,6,1,7,9]]

-- Invalid board (duplicate 5 in first row)
badBoard = [[5,3,4,6,7,8,9,1,5],
            [6,7,2,1,9,5,3,4,8],
            [1,9,8,3,4,2,5,6,7],
            [8,5,9,7,6,1,4,2,3],
            [4,2,6,8,5,3,7,9,1],
            [7,1,3,9,2,4,8,5,6],
            [9,6,1,5,3,7,2,8,4],
            [2,8,7,4,1,9,6,3,5],
            [3,4,5,2,8,6,1,7,9]]

-- Tests:
-- validSudoku board     → True
-- validSudoku badBoard  → False

=== Pascal's Triangle ===
-- Generate rows of Pascal's Triangle as strings with spaces

-- zipWith applies a function to pairs of elements
zipWith f [] _ = []
zipWith f _ [] = []
zipWith f (x:xs) (y:ys) = f x y : zipWith f xs ys

-- Generate next row from current row
nextRow row = zipWith (+) ([0] ++ row) (row ++ [0])

-- Generate the nth row (0-indexed)
pascalRow 0 = [1]
pascalRow n = nextRow (pascalRow (n-1))

-- Join list of numbers with spaces
joinWithSpaces [] = ""
joinWithSpaces [x] = show x
joinWithSpaces (x:xs) = show x ++ " " ++ joinWithSpaces xs

-- Generate all rows from 0 to n
pascalRows n = [pascalRow i | i <- [0..n]]

-- Display n rows as strings with spaces
pascal n = map joinWithSpaces (pascalRows n)

-- Tests:
-- pascal 0   → ["1"]
-- pascal 1   → ["1","1 1"]
-- pascal 4   → ["1","1 1","1 2 1","1 3 3 1","1 4 6 4 1"]
-- pascal 6   → ["1","1 1","1 2 1","1 3 3 1","1 4 6 4 1","1 5 10 10 5 1","1 6 15 20 15 6 1"]

=== Sudoku Solver ===
{- Solves a 9x9 Sudoku puzzle using backtracking
   Board representation: 0 represents empty cells, 1-9 are filled cells

   PERFORMANCE NOTE: This algorithm has exponential time complexity O(k^n)
   where k=9 (possible values) and n=number of empty cells.
   Backtracking with constraint checking makes it practical for typical puzzles.
   The key optimization is avoiding redundant computation by computing each
   recursive solve() only once per attempt. -}

-- Helper: Check if element is in list
elem x [] = False
elem x (y:ys) = if x == y then True else elem x ys

-- Helper: Get element at position (row, col) in 2D list
getAt board row col = (board !! row) !! col

-- Helper: Set element at position in 2D list
setAt board row col val = [if r == row then [if c == col then val else getAt board r c | c <- [0..8]] else board !! r | r <- [0..8]]

-- Helper: Get all numbers in a row
getRow board row = board !! row

-- Helper: Get all numbers in a column
getCol board col = [row !! col | row <- board]

-- Helper: Get the 3x3 box containing position (row, col)
getBox board row col = [board !! r !! c | r <- [(boxRow row)..(boxRow row)+2], c <- [(boxCol col)..(boxCol col)+2]]
boxRow row = (div row 3) * 3
boxCol col = (div col 3) * 3

{- Tuple accessors -}
fst (x, _) = x
snd (_, y) = y

{- Check if a number is valid at a position -}
isValid board row col num = not (elem num (getRow board row)) && not (elem num (getCol board col)) && not (elem num (getBox board row col))

{- Find first empty cell (returns (-1,-1) if none) -}
findEmpty board = findEmptyHelper board 0 0

findEmptyHelper board 9 _ = (-1, -1)
findEmptyHelper board row 9 = findEmptyHelper board (row + 1) 0
findEmptyHelper board row col
  | getAt board row col == 0 = (row, col)
  | otherwise = findEmptyHelper board row (col + 1)

{- Check if position is (-1,-1) -}
isNoEmpty pos = fst pos == -1 && snd pos == -1

{- Try to solve from current position -}
solve board
  | isNoEmpty (findEmpty board) = board
  | otherwise = solveFrom board (findEmpty board)

{- Solve from a known empty position -}
solveFrom board pos = tryNumbers board (fst pos) (snd pos) [1..9]

{- Try each number in the list -}
tryNumbers board _ _ [] = []
tryNumbers board row col (n:ns)
  | not (isValid board row col n) = tryNumbers board row col ns
  | otherwise = checkSolution (solve (setAt board row col n)) board row col ns

{- Check if solution worked, backtrack if not -}
checkSolution result board row col ns
  | null result = tryNumbers board row col ns
  | otherwise = result

{- Almost-solved puzzle (only 1 empty cell - solves instantly) -}
simplePuzzle = [[5,3,4,6,7,8,9,1,2],[6,7,2,1,9,5,3,4,8],[1,9,8,3,4,2,5,6,7],[8,5,9,7,6,1,4,2,3],[4,2,6,8,5,3,7,9,1],[7,1,3,9,2,4,8,5,6],[9,6,1,5,3,7,2,8,4],[2,8,7,4,1,9,6,3,5],[3,4,5,2,8,6,1,7,0]]

{- Distributed blanks (10 empty cells - solves quickly!)
   Interestingly, this can solve FASTER than puzzles with fewer blanks
   because early constraints prune the search tree more effectively -}
easyPuzzle = [[5,3,4,6,0,8,9,1,2],[6,7,2,1,0,5,3,4,8],[1,9,8,0,4,2,5,6,7],[8,5,9,7,6,1,4,2,3],[4,2,6,8,5,3,7,9,0],[7,1,3,9,2,4,8,0,0],[9,6,1,5,0,7,2,8,0],[2,8,7,4,1,9,6,3,0],[3,4,5,0,8,6,1,7,9]]

{- More challenging (typical puzzle - may be too slow) -}
mediumPuzzle = [[5,3,0,0,7,0,0,0,0],[6,0,0,1,9,5,0,0,0],[0,9,8,0,0,0,0,6,0],[8,0,0,0,6,0,0,0,3],[4,0,0,8,0,3,0,0,1],[7,0,0,0,2,0,0,0,6],[0,6,0,0,0,0,2,8,0],[0,0,0,4,1,9,0,0,5],[0,0,0,0,8,0,0,7,9]]

-- Tests:
-- solve simplePuzzle  → (instant - 1 empty cell)
-- solve easyPuzzle    → (fast - 10 empty cells, well-distributed)  
-- solve mediumPuzzle  → (may timeout - 50+ empty cells clustered together)
-- getAt (solve simplePuzzle) 8 8  → 9