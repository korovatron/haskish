=== Using the REPL ===
Get familiar with the Interactive **_REPL_** (**R**ead-**E**val-**P**rint **L**oop).
The REPL shows results immediately. 

**~Experiment!~**

Try these expressions:

```
> 5 + 7
> 8 / 4
> True && False
> not (False && True)
> 7 == 7
> 5 /= 5
> 5 /= 6
> "hello" == "world"
> min 64 128
> max 128 64
> mod 14 3
> mod 14 3 == 0
> div 14 3
> max "apple" "banana"
> (2 == 3) || (2 == 2)
> ord "A"
> chr 98
```

**~Questions~**

What is the purpose of `&&` and `||` ?

What does `/=` mean?

What is the significance of `ord` and `chr` ?

What do `mod` and `div` do? Try different values to help you decide.

=== Variables ===
In the REPL define some **_variables_**
```
> x = 7
> y = 2
> myValue = 17
> mySecondValue = -12
```
You can use these variables as values in expressions. Try the following, and some of your own:
```
> myValue + 3
> y - mySecondValue
> y == 7
> y == 2
> myValue < 15
> not (myValue > 15)
> myNewValue = x + y
> myNewValue + 11
```
What happens if you now try
```
> myValue = 10
```
or
```
> y = 42
```
In functional programming variables and other data structures are **_immutable_**. This means that the values stored in them cannot be changed after being created.

This is particularly important when working with **_Big Data_**: Big Data is distributed across multiple devices, so immutability ensures that values stored cannot be changed after being created, preventing conflicts when multiple devices process the same data simultaneously.

You can use the **RESET** button `<svg width="16" height="16" viewBox="0 0 1200 1200" fill="currentColor" style="vertical-align: middle;"><path d="M600,0C308.74,0,66.009,207.555,11.499,482.812h166.553C229.37,297.756,398.603,161.719,600,161.719c121.069,0,230.474,49.195,309.668,128.613l-192.48,192.48h304.762H1200V0l-175.781,175.781C915.653,67.181,765.698,0,600,0z M0,717.188V1200l175.781-175.781C284.346,1132.819,434.302,1200,600,1200c291.26,0,533.991-207.555,588.501-482.812h-166.553C970.631,902.243,801.396,1038.281,600,1038.281c-121.069,0-230.474-49.195-309.668-128.613l192.48-192.48H0z"/></svg>` in the REPL to clear the output as well as all variable definitions.

=== Simple Functions ===
In addition to the built-in **_functions_**, you can define your own.

In the REPL type the following:
```
> add x y = x + y
```
then try the following ...
```
> add 4 5
> add (-6) 7
```
`add` is the **_identifier_** (name of the function).

`x` `y` are the **_parameters_** of the function.

`= x + y` defines what the function does.

When we type 
```
> add (-6) 7
```
the `(-6)` and `7` are the **_arguments_** that are passed into the **parameters** `x` and `y`.

**_Note:_** **When passing negative numbers as arguments, always use parentheses, e.g., `(-6)` not `-6`**.
This avoids confusion with the subtraction operator.

**~Challenges:~**

Now write functions to perform the following tasks:

- `tripleMe` - Accepts one parameter and returns three times its value
```
> tripleMe 5
15
```

- `doubleAdd` - Accepts two parameters, doubles each of them, then adds them together
```
> doubleAdd 3 4
14
```

- `subtractThenDouble` - Accepts two parameters, subtracts the second from the first, then doubles the result
```
> subtractThenDouble 10 3
14
```

- `isGreaterThan100` - Accepts two parameters, adds them together, and returns `True` if the sum is greater than 100
```
> isGreaterThan100 60 50
True
> isGreaterThan100 30 40
False
```

- `averageTwo` - Accepts two parameters and returns their average
```
> averageTwo 10 20
15
> averageTwo 7 8
7.5
```

- `minutesToHours` - Accepts a number of minutes and returns how many complete hours. Use `div` for integer division
```
> minutesToHours 150
2
> minutesToHours 90
1
```

- `isEven` - Accepts one parameter and returns `True` if the number is even, `False` otherwise. Use `mod` to find the remainder
```
> isEven 8
True
> isEven 7
False
```



=== Using the Function Panel ===
So far we've been writing functions in the REPL. For more complex programs, we use the **_Function Definition Panel_**.

The function panel lets you:

- Write multiple functions that work together
- Save your work
- Build more complex programs using helper functions

Try writing these helper functions in the function panel:

First, write a simple `square` function:
```
square x = x * x
```

Click **Run Code** `<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" style="vertical-align: middle;"><path d="M3 2l10 6-10 6V2z"/></svg>` to make the function available in the REPL. Then test it:
```
> square 5
25
> square 12
144
```

Now add a function that uses `square` as a helper. Add this to the function panel (above or below `square`):
```
sumOfSquares a b = square a + square b
```

Click **Run Code** <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" style="vertical-align: middle;"><path d="M3 2l10 6-10 6V2z"/></svg> again and test:
```
> sumOfSquares 3 4
25
> sumOfSquares 5 12
169
```

Notice how `sumOfSquares` **calls** the `square` function as a helper. Breaking problems into smaller helper functions makes code easier to understand and reuse.

**~Challenge~**

Now write a complete program with helper functions:

`isRightTriangle` - Accepts three parameters (sides of a triangle) and returns `True` if they form a right-angled triangle using Pythagoras' theorem (a² + b² = c²).

You'll need these helper functions:

- `square x` - returns x squared
- `sumOfSquares a b` - returns the sum of a² and b²
- `isRightTriangle a b c` - checks if a² + b² = c²

Example:
```
> isRightTriangle 3 4 5
True
> isRightTriangle 5 12 13
True
> isRightTriangle 1 2 3
False
```

Remember: Write all three functions in the function panel, click **Run Code** `<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" style="vertical-align: middle;"><path d="M3 2l10 6-10 6V2z"/></svg>`, then test in the REPL!

=== Building More Complex Programs ===

**~Challenge~**

Now create a more complex program with multiple helper functions.

Write a program to analyse quadratic equations (ax² + bx + c = 0). 

The **discriminant** tells us how many real solutions the equation has:

- discriminant = b² - 4ac
- If discriminant > 0, there are **two** real roots
- If discriminant = 0, there is **one** real root (repeated)
- If discriminant < 0, there are **no** real roots

Build these functions in the function panel:

`discriminant a b c` - Calculates b² - 4ac

`hasRealRoots a b c` - Returns `True` if the equation has at least one real root

`hasTwoRoots a b c` - Returns `True` if the equation has two distinct real roots

`hasOneRoot a b c` - Returns `True` if the equation has exactly one root

Think about what helper functions you might need (hint: you've written similar ones before!).

Example tests:
```
> discriminant 1 (-5) 6
1
> hasRealRoots 1 (-5) 6
True
> hasTwoRoots 1 (-5) 6
True
> hasOneRoot 2 4 2
True
> hasRealRoots 1 0 1
False
```

=== Introduction to Lists ===
**_Lists_** are collections of values of the same data type. They are enclosed in `[ ]`. Lists can be **_finite_** or **_infinite_** in length.

Try making some lists ...

```
> [45,23,9,78]
> [8..15]
> [5..]
> [3,7..50]
> [5,3..-20]
> heroes = ["superman", "spiderman", "batman"]
```
Now try the following, taking note of any **errors**:
```
> head heroes
> tail heroes
> null heroes
> "thor" : heroes
> heroes : "thor"
> extraHeroes = "thing" : heroes
> heroesAndVillains = extraHeroes ++ ["joker","magneto"]
> "kingpin" ++ heroesAndVillains
> length heroesAndVillains
```
**~Questions~**

- What does `head` do?
- What does `tail` do?
- What is the purpose of `null`?
- Describe the purpose of the cons operator `:`
- What does `++` do?
- Why does `heroes : "thor"` throw an error?
- What is wrong with `"kingpin" ++ heroesAndVillains`?

Now try the following commands, carefully noting any **errors**:
```
> take 2 heroesAndVillains
> drop 2 heroesAndVillains
> tail head heroesAndVillains
> tail [head heroesAndVillains]
> tail (head heroesAndVillains)
> head tail heroesAndVillains
> head (tail heroesAndVillains)
> heroesAndVillains !! 0
> heroesAndVillains !! 1
> heroesAndVillains !! 2
```

**~Questions~**

- What does `take` do?
- What does `drop` do?
- What is the purpose of `!!`?
- What is the problem with `tail head heroesAndVillains`?
- What does the result of `tail (head heroesAndVillains)` tell you about how strings are stored?

Finally try out these code snippets:
```
> length heroesAndVillains == 6
> length (tail heroesAndVillains) == 5
> (heroesAndVillains !! 1) == "thing"
> head (heroesAndVillains !! 1) == head (heroesAndVillains !! 2)
```

- Can you explain the last result?

=== Pattern Matching & Recursion ===
**_Recursion_** allows a function to call itself with a simpler version of the problem.
Every recursive function needs:

- A **_base case_** - when to stop recursing
- A **_recursive case_** - how to break down the problem

**~Example 1: Factorial~**

Factorial is defined mathematically as:

- 0! = 1 (base case)
- n! = n × (n-1)! (recursive case)

**Define the factorial function** in the function definition panel:
```
factorial 0 = 1
factorial n = n * factorial (n-1)
```

**Trace the execution:**
```
> factorial 4
= 4 * factorial 3
= 4 * 3 * factorial 2
= 4 * 3 * 2 * factorial 1
= 4 * 3 * 2 * 1 * factorial 0
= 4 * 3 * 2 * 1 * 1
= 24
```

**Try it:**
```
> factorial 5
> factorial 10
> factorial 0
```

**~Challenge~**

Now write a function `fib` that calculates the nth Fibonacci number:

```
> fib 5
5
> fib 10
55
> fib 25
75025
> fib 35
????
```

- Can you explain What happens with `fib 35`? If you look in the **Recursion Examples** in the menu, you will see an implementation `fastFib` that does not have this issue. It uses a technique called **Tail Recursion with Accumulators**. 

**~Example 2: Pattern Matching with Lists~**

**Pattern matching** lets you define functions by matching on the *structure* of data.
Lists can be matched as either `[]` (empty) or `(x:xs)` (head and tail).

The `length` function can be defined recursively:

```
calcLength [] = 0
calcLength (x:xs) = 1 + calcLength xs
```

- **Base case:** An empty list `[]` has length 0
- **Recursive case:** A list `(x:xs)` has length 1 (for head `x`) plus the length of the tail `xs`

**Trace the execution:**
```
> calcLength ['a', 'b', 'c', 'd']
= 1 + calcLength ['b', 'c', 'd']
= 1 + 1 + calcLength ['c', 'd']
= 1 + 1 + 1 + calcLength ['d']
= 1 + 1 + 1 + 1 + calcLength []
= 1 + 1 + 1 + 1 + 0
= 4
```

**Try it:**
```
> calcLength [1,2,3,4,5]
> calcLength "hello"
> calcLength []
```

**~Challenges:~** 

Write similar recursive functions:

- `sumList` - adds all numbers in a list (base: empty list = 0)
- `productList` - multiplies all numbers in a list (base: empty list = 1)
- `replicateEach` - replicates each element in a list twice (base: empty list = [], **hint:** cons the head twice onto the result of recursing on the tail)
```
> replicateEach [1,2,3]
[1,1,2,2,3,3]
> replicateEach "hi"
"hhii"
```

**~Tougher Challenges:~**

- `appendToEach` - appends a given element to the end of each sublist
```
> appendToEach 0 [[1,2],[3,4],[5]]
[[1,2,0],[3,4,0],[5,0]]
> appendToEach '!' ["hello","world"]
["hello!","world!"]
```

- `flatten` - flattens a list of lists into a single list. **Hint:** Use `++` to join the head list with the flattened tail
```
> flatten [[1,2],[3,4],[5,6]]
[1,2,3,4,5,6]
> flatten [["hello"],["world"]]
["hello","world"]
```

- `pairUp` - pairs up consecutive elements from a list. **Hint:** You need to match `(x:y:xs)` to get two elements at once
```
> pairUp [1,2,3,4,5,6]
[(1,2),(3,4),(5,6)]
> pairUp "hello"
[('h','e'),('l','l')]
```

- `countOccurrences` - counts how many times an element appears in a list. **Hint:** Match `(x:xs)`, check if `x` equals the target, then recurse
```
> countOccurrences 3 [1,3,2,3,3,4]
3
> countOccurrences 'a' "banana"
3
```

=== Guards & Conditionals ===

Haskish supports two main ways to make decisions in your code: **_Guards_** and **_Conditional expressions (if-then-else)_**.

One of the challenges from the previous exercise was to write `countOccurrences` to count how many times an element appears in a list. One way to solve this is with a helper function `boolToInt`:

```
boolToInt True  = 1
boolToInt False = 0

countOccurrences e [] = 0
countOccurrences e (x:xs) = boolToInt (e == x) + countOccurrences e xs
```

However, there are clearer ways to do this using guards or conditionals.

**_Conditional Expressions (if-then-else)_**

An `if-then-else` expression lets you choose between two values based on a condition. Both `then` and `else` branches are required because the expression must always return a value.

```
countOccurrences e [] = 0
countOccurrences e (x:xs) = if e == x then 1 + countOccurrences e xs else countOccurrences e xs
```

This is good for simple **binary choices** (one thing or another).

**_Guards_**

Guards let you test multiple conditions in sequence. Each guard starts with `|` (pipe symbol) followed by a boolean condition:

```
countOccurrences e [] = 0
countOccurrences e (x:xs)
  | e == x    = 1 + countOccurrences e xs
  | otherwise = countOccurrences e xs
```

The `otherwise` keyword is just `True` - it catches any case that doesn't match the earlier guards. Guards are especially useful when you have **multiple conditions** to check.

**When to use which:**
- **if-then-else:** Simple binary choice between two options
- **Guards:** Multiple conditions or when the logic reads more naturally as a list of cases

**~Practice with Guards and Conditionals~**

Now practice using guards and if-then-else with these challenges:

- `switchBinary` - Given a list of binary digits (0s and 1s), return a new list with 0s changed to 1s and 1s changed to 0s. **Hint:** Use guards to check if `x == 0` or `x == 1`
```
> switchBinary [0,1,1,0,1]
[1,0,0,1,0]
> switchBinary [1,1,1]
[0,0,0]
```

- `countTwoElems` - Count how many times either of two given elements appear in a list. **Hint:** You'll need two guard conditions before `otherwise`
```
> countTwoElems 2 3 [1,2,3,2,4,3]
4
> countTwoElems 'a' 'e' "hello world"
1
```

- `inList` - Return `True` if a given element appears in the list, `False` otherwise
```
> inList 5 [1,3,5,7]
True
> inList 4 [1,3,5,7]
False
> inList 'x' "hello"
False
```

- `removeAll` - Remove all occurrences of a given element from a list
```
> removeAll 2 [1,2,3,2,4,2]
[1,3,4]
> removeAll 'l' "hello"
"heo"
```

- `removeFirst` - Remove only the first occurrence of a given element from a list. **Hint:** When you find the match, just return `xs` instead of recursing
```
> removeFirst 2 [1,2,3,2,4]
[1,3,2,4]
> removeFirst 'l' "hello"
"helo"
```

- `replace` - Replace all instances of one element with another element
```
> replace 2 9 [1,2,3,2,4]
[1,9,3,9,4]
> replace 'o' 'a' "hello"
"hella"
```

**~Advanced Challenges - Using Helper Functions~**

These next challenges use a common pattern: a main function that calls a helper function with an extra parameter (often called an **accumulator**) to track something as we recurse through the list.

- `multEvenIdx` - Multiply all values at even-numbered indices (0, 2, 4, ...). **Hint:** Create a helper function that takes an extra parameter `n` to track the current index
```
> multEvenIdx [1,2,3,4,5]
15
> multEvenIdx [2,10,3,10,5,10]
30
```

- `multEvenNums` - Multiply all the even numbers in a list (return 1 if there are none). **Hint:** Use the built-in `even` function
```
> multEvenNums [1,2,3,4,5,6]
48
> multEvenNums [1,3,5]
1
```

- `insertEvenPos` - Insert a given element at all even positions in a list (positions 0, 2, 4, ...). **Hint:** The pattern is `e : x : insertEvenPos e xs`
```
> insertEvenPos 0 [1,2,3]
[0,1,0,2,0,3,0]
> insertEvenPos 'x' "abc"
"xaxbxcx"
```

- `multBy` - Multiply every element in a list by a given number
```
> multBy 3 [1,2,3,4]
[3,6,9,12]
> multBy 10 [5,10,15]
[50,100,150]
```



