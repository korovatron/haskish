=== Using the REPL ===
Get familiar with the Interactive **_REPL_** (**R**ead-**E**val-**P**rint **L**oop).
The REPL shows results immediately. 

**~Important: Characters vs Strings~**

In Haskish (like Haskell), there's an important distinction:

- **Single quotes** `'a'` create a **Char** (a single character)
- **Double quotes** `"abc"` create a **String** (a list of characters)

So `"hello"` is actually the same as `['h','e','l','l','o']` - a list of individual characters!

This is why functions like `ord` (which converts a character to its numeric code) require a **Char**, not a String:
- ✅ `ord 'A'` works (single character)
- ❌ `ord "A"` doesn't work (that's a list containing one character)

**~Experiment~**

Try these expressions:

```
> 5 + 7
> 8 / 4
> True && False
> not (False && True)
> 7 == 7
> 5 /= 5
> 5 /= 6
> "hello" == "world"
> min 64 128
> max 128 64
> mod 14 3
> mod 14 3 == 0
> div 14 3
> max "clockwork" "orange"
> (2 == 3) || (2 == 2)
> ord 'A'
> chr 98
```

**~Questions~**

What is the purpose of `&&` and `||` ?

What does `/=` mean?

What is the significance of `ord` and `chr` ?

What do `mod` and `div` do? Try different values to help you decide.

=== Variables ===
In the REPL define some **_variables_**
```
> x = 7
> y = 2
> myValue = 17
> mySecondValue = -12
```
You can use these variables as values in expressions. Try the following, and some of your own:
```
> myValue + 3
> y - mySecondValue
> y == 7
> y == 2
> myValue < 15
> not (myValue > 15)
> myNewValue = x + y
> myNewValue + 11
```
What happens if you now try
```
> myValue = 10
```
or
```
> y = 42
```
In functional programming variables and other data structures are **_immutable_**. This means that the values stored in them cannot be changed after being created.

This is particularly important when working with **_Big Data_**: Big Data is distributed across multiple devices, so immutability ensures that values stored cannot be changed after being created, preventing conflicts when multiple devices process the same data simultaneously.

You can use the **RESET** button `<svg width="16" height="16" viewBox="0 0 1200 1200" fill="currentColor" style="vertical-align: middle;"><path d="M600,0C308.74,0,66.009,207.555,11.499,482.812h166.553C229.37,297.756,398.603,161.719,600,161.719c121.069,0,230.474,49.195,309.668,128.613l-192.48,192.48h304.762H1200V0l-175.781,175.781C915.653,67.181,765.698,0,600,0z M0,717.188V1200l175.781-175.781C284.346,1132.819,434.302,1200,600,1200c291.26,0,533.991-207.555,588.501-482.812h-166.553C970.631,902.243,801.396,1038.281,600,1038.281c-121.069,0-230.474-49.195-309.668-128.613l192.48-192.48H0z"/></svg>` in the REPL to clear the output as well as all variable definitions.

=== Simple Functions ===
In addition to the built-in **_functions_**, you can define your own.

In the REPL type the following:
```
> add x y = x + y
```
then try the following ...
```
> add 4 5
> add (-6) 7
```
`add` is the **_identifier_** (name of the function).

`x` `y` are the **_parameters_** of the function.

`= x + y` defines what the function does.

When we type 
```
> add (-6) 7
```
the `(-6)` and `7` are the **_arguments_** that are passed into the **parameters** `x` and `y`.

**_Note:_** **When passing negative numbers as arguments, always use parentheses, e.g., `(-6)` not `-6`**.
This avoids confusion with the subtraction operator.

**~Challenges:~**

Now write functions to perform the following tasks:

- `tripleMe` - Accepts one parameter and returns three times its value
```
> tripleMe 5
15
```

- `doubleAdd` - Accepts two parameters, doubles each of them, then adds them together
```
> doubleAdd 3 4
14
```

- `subtractThenDouble` - Accepts two parameters, subtracts the second from the first, then doubles the result
```
> subtractThenDouble 10 3
14
```

- `isGreaterThan100` - Accepts two parameters, adds them together, and returns `True` if the sum is greater than 100
```
> isGreaterThan100 60 50
True
> isGreaterThan100 30 40
False
```

- `averageTwo` - Accepts two parameters and returns their average
```
> averageTwo 10 20
15
> averageTwo 7 8
7.5
```

- `minutesToHours` - Accepts a number of minutes and returns how many complete hours. Use `div` for integer division
```
> minutesToHours 150
2
> minutesToHours 90
1
```

- `isEven` - Accepts one parameter and returns `True` if the number is even, `False` otherwise. Use `mod` to find the remainder
```
> isEven 8
True
> isEven 7
False
```


=== Partial Function Application ===

In **mathematics**, a function maps a **single** value from its **_domain_** to a **single** value in its **_co‑domain_**.
For example:
```
add(x, y) = x + y
```

This looks like a function taking two values, but in mathematics it is formally treated as taking one input, which is a pair of integers such as `(3,4)`.
So the domain is the set of all integer pairs:
```
{ (0,0), (0,1), (0,2), …
  (1,0), (1,1), (1,2), …
  … }
```  
This set is called the **_Cartesian product_** of ℤ with itself.
We write the **_type definition_** as 
```
add : ℤ × ℤ → ℤ
```
meaning: a single **pair** of integers is mapped to a **single** integer.

Functional programming languages use a different representation called **_currying_**.
In Haskish (and Haskell) we can define:
```
add x y = x + y
```
In Haskish, spaces separate items in both function definitions (parameters) and function calls (arguments). No commas or parentheses are needed.
Haskish interprets this as:

"`add` is a function that takes one parameter `x` and returns a new function that takes one parameter `y`."

**_Function application_** is the process of passing arguments to a function.
When you write:
```
add 3 5
```
it is really
```
(add 3) 5
```
because function application is left‑associative. The steps are:

1. `add 3` creates a new function that adds 3 to its input

2. That new function is then applied to 5

3. The result is 8

In other words, `add 3 5` is actually shorthand for `(add 3) 5`

In Haskish (and Haskell) we write the **_type definition_** for the function

```
add x y = x + y
```

as

<div style="font-family: monospace; padding: 10px; background: #2a2a2a; border-radius: 4px; margin: 10px 0;">
add :: <span style="color: #2196F3; font-weight: bold;">Integer</span> <span style="color: #FF9800; font-weight: bold;">-></span> <span style="color: #9C27B0; font-weight: bold;">(</span><span style="color: #4CAF50; font-weight: bold;">Integer</span> <span style="color: #9C27B0; font-weight: bold;">-></span> <span style="color: #F44336; font-weight: bold;">Integer</span><span style="color: #9C27B0; font-weight: bold;">)</span>
</div>

or more concisely as

<div style="font-family: monospace; padding: 10px; background: #2a2a2a; border-radius: 4px; margin: 10px 0;">
add :: <span style="color: #2196F3; font-weight: bold;">Integer</span> <span style="color: #FF9800; font-weight: bold;">-></span> <span style="color: #4CAF50; font-weight: bold;">Integer</span> <span style="color: #9C27B0; font-weight: bold;">-></span> <span style="color: #F44336; font-weight: bold;">Integer</span>
</div>

This shows how the function definition maps to the type:

<div style="font-family: monospace; padding: 10px; background: #2a2a2a; border-radius: 4px; margin: 10px 0;">
add <span style="color: #2196F3; font-weight: bold;">x</span> <span style="color: #4CAF50; font-weight: bold;">y</span> = <span style="color: #2196F3; font-weight: bold;">x</span> + <span style="color: #4CAF50; font-weight: bold;">y</span>
</div>

meaning: the function takes **<span style="color: #2196F3">one integer (x)</span>** and returns a **<span style="color: #FF9800">function</span>**. That **<span style="color: #9C27B0">new function</span>** takes another **<span style="color: #4CAF50">integer (y)</span>** and returns the **<span style="color: #F44336">final result</span>**. Each arrow represents a function. 

Try this in the REPL:
```
> add x y = x + y
> add 3 5
8
> addThree = add 3
> addThree 5
8
> addThree 10
13
```

Notice how `addThree = add 3` creates a specialised function. This is called **_partial function application_** (or just **_partial application_**) - applying some but not all of the arguments to create a new, more specialised function.

**More Examples**

```
> multiply x y = x * y
> double = multiply 2
> triple = multiply 3
> double 7
14
> triple 7
21
```

```
> greet greeting name = greeting ++ ", " ++ name ++ "!"
> sayHello = greet "Hello"
> sayGoodbye = greet "Goodbye"
> sayHello "Clarice"
"Hello, Clarice!"
> sayGoodbye "cruel world"
"Goodbye, cruel world!"
```

Partial application is incredibly useful for creating specialised functions from general ones without writing repetitive code.

**~Challenges:~**

Try creating some specialised functions through partial application.

- Create a function `subtract x y = x - y`, then use partial application to create `subtractFromHundred` (which subtracts its argument from 100).
```
> subtractFromHundred 30
70
> subtractFromHundred 5
95
```

- Create a function `addSuffix suffix text = text ++ suffix`, then use partial application to create `addExclamation` (which adds "!" to text)
```
> addExclamation "Real horrorshow"
"Real horrorshow!"
```

- Use the built-in `min` function with partial application to create `capAt100` (which ensures a value doesn't exceed 100)
```
> capAt100 75
75
> capAt100 150
100
```

- Create a function `addPrefix prefix text = prefix ++ text`, then use partial application to create `addMr` (which adds "Mr. " to names)
```
> addMr "Spock"
"Mr. Spock"
> addMr "Benn"
"Mr. Benn"
```

**_Why This Matters_**

Partial application allows you to:
- Create specialised functions without writing new code
- Build complex functions by combining simpler ones

This is a fundamental concept in functional programming that you'll use throughout your journey with Haskish and other functional languages such as Haskell.


=== First-Class Functions ===

In the previous exercise, when you wrote `addTen = add 10`, you were assigning a function to a variable. This works because in functional programming languages, **_functions are first-class objects_** (also called **first-class values**).

**_What does "first-class object" mean?_**

A **_first-class object_** is a value that can be:
- **Assigned to a variable** - store it for later use
- **Passed as an argument** - give it to another function
- **Returned from a function** - be the result that a function gives back
- **Used in expressions** - appear anywhere a value can appear

You're already familiar with first-class objects! In most programming languages, integers, floating-point numbers, characters, and strings are all first-class objects:

```
> x = 5
> y = x + 3
> numbers = [1, 2, 3]
> myString = "hello"
```

In functional programming, **functions are treated the same way** - they're just another type of value.

**_Functions as Variables_**

You've already done this with partial application:

```
> add x y = x + y
> addTen = add 10
> double x = x * 2
> myFunction = double
> myFunction 7
14
```

**_Functions as Arguments_**

Functions can be passed to other functions. Here's a simple example - a function that applies another function twice:

```
> applyTwice f x = f (f x)
> double n = n * 2
> applyTwice double 3
12
```

Let's trace this: `applyTwice double 3` means `double (double 3)` = `double 6` = `12`

Another example - a function that chooses between two functions based on a condition:

```
> chooseFunction condition f g x = if condition then f x else g x
> double n = n * 2
> triple n = n * 3
> chooseFunction True double triple 5
10
> chooseFunction False double triple 5
15
```

**_Functions as Return Values_**

Functions can return other functions (you've seen this with partial application!):

```
> makeAdder n = \x -> x + n
> addFive = makeAdder 5
> addTen = makeAdder 10
> addFive 3
8
> addTen 3
13
```

The `\x -> x + n` is a **_lambda function_** (anonymous function) - we'll explore these more later.

**~Challenges:~**

- Write a function `applyThrice` that takes a function and a value, and applies the function three times
```
> double n = n * 2
> applyThrice double 1
8
> addOne n = n + 1
> applyThrice addOne 0
3
```

- Write a function `applyToFive` that takes a function as an argument and applies it to the number 5
```
> double n = n * 2
> applyToFive double
10
> square n = n * n
> applyToFive square
25
```

- Write a function `doTwice` that takes a function `f` and a value `x`, and returns a function that when called with a value `y`, computes `f (f x) + y`.
```
> doTwice double 3
&lt;function doTwice with 2 bound arg(s)&gt;
> (doTwice double 3) 1
13
```
The result is `double (double 3) + 1` = `12 + 1` = `13`

- Write a function `applyBoth` that takes two functions `f` and `g`, and a value `x`, then returns `f x + g x`
```
> double n = n * 2
> triple n = n * 3
> applyBoth double triple 4
20
```
Because `double 4 + triple 4` = `8 + 12` = `20`

**_Why This Matters_**

Understanding that functions are first-class objects is fundamental to functional programming. It allows you to:
- Write more flexible and reusable code
- Create powerful abstractions
- Build functions that can work with any operation (which you'll see with `map`, `filter`, and `fold` later!)


=== Function Composition ===

Now that you understand functions are first-class objects, you can learn a powerful way to combine them:

**_Function composition_** is the operation of combining two functions to create a new function. The output of one function becomes the input to another.

**_Mathematical Notation_**

Given two functions:
- `f: A → B` (takes values from set A, returns values in set B)
- `g: B → C` (takes values from set B, returns values in set C)

The **_composition_** `g ○ f` (read as "g composed with f" or "g after f") creates a new function:
- `g ○ f: A → C`

**_Notice_** how the co-domain of `f` (which is `B`) matches the domain of `g` (which is also `B`). This is required for composition to work!

**_Order of Application_**

**Important:** In `g ○ f`, the function `f` is applied **first**, then `g` is applied to the result.

Think of it like a pipeline: value → f → result → g → final result

**Example from Mathematics**

If `f(x) = x + 2` and `g(y) = y³`, then:

```
g ○ f = (x + 2)³
```

Step by step with `x = 3`:

1. Apply `f` first: `f(3) = 3 + 2 = 5`

2. Apply `g` to the result: `g(5) = 5³ = 125`

So `(g ○ f)(3) = 125`

**_Function Composition in Haskish_**

In Haskish, we use the `.` operator for composition (instead of `○`):

```
> addTwo x = x + 2
> cube x = x * x * x
> addThenCube = cube . addTwo
> addThenCube 3
125
```

Let's trace this:
- `addThenCube 3` = `(cube . addTwo) 3`
- First apply addTwo: `addTwo 3` = `5`
- Then apply cube: `cube 5` = `125`

**_More Examples_**

```
> double x = x * 2
> square x = x * x
> doubleAndSquare = square . double
> doubleAndSquare 3
36
```

Because: `double 3` = `6`, then `square 6` = `36`

```
> addOne x = x + 1
> triple x = x * 3
> addOneThenTriple = triple . addOne
> addOneThenTriple 4
15
```

Because: `addOne 4` = `5`, then `triple 5` = `15`

**_Composing Multiple Functions_**

You can compose more than two functions:

```
> addOne x = x + 1
> double x = x * 2
> square x = x * x
> f = square . double . addOne
> f 2
36
```

Let's trace: `f 2` = `square (double (addOne 2))`

1. `addOne 2` = `3`

2. `double 3` = `6`

3. `square 6` = `36`

Remember: functions are applied **_right to left_** (the rightmost function is applied first).

**_Domain and Co-domain Matching_**

For composition to work, the types must match:

```
f: A → B
g: B → C
g . f: A → C  ✓ (B matches!)

f: A → B
h: D → E
h . f: ???  ✗ (B ≠ D, cannot compose!)
```

**~Challenges:~**

- Define `addFive x = x + 5` and `double x = x * 2`, then create `addFiveThenDouble` using composition
```
> addFiveThenDouble 3
16
```

- Define `square x = x * x` and `addThree x = x + 3`, then create `squareThenAddThree` using composition
```
> squareThenAddThree 4
19
```

- Create a composition `addThenDoubleSquared` that adds 1, doubles the result, then squares it. You'll need to define three functions and compose them
```
> addThenDoubleSquared 2
36
```
Because: `(2 + 1) * 2 = 6`, then `6² = 36`

- Define `half x = x / 2` and `square x = x * x`. Create two different compositions: `halfThenSquare` and `squareThenHalf`. Test them both with the same input to see they give different results!
```
> halfThenSquare 10
25
> squareThenHalf 10
50
```

- The built-in `head` function gets the first element of a list, and `tail` gets all but the first. Create a function `secondElement` that gets the second element of a list using composition. **Hint:** Think about what operation gives you the second element
```
> secondElement [10,20,30,40]
20
> secondElement "hello"
'e'
```

**_Why This Matters_**

Function composition allows you to:
- Build complex operations from simple building blocks
- Write more readable code (describing the pipeline of transformations)
- Avoid creating temporary variables
- Think in terms of data transformations

This is a fundamental technique in functional programming and you'll use it extensively!


=== Using the Function Panel ===
So far we've been writing functions in the REPL. For more complex programs, we use the **_Function Definition Panel_**.

The function panel lets you:

- Write multiple functions that work together
- Save your work
- Build more complex programs using helper functions

Try writing these helper functions in the function panel:

First, write a simple `square` function:
```
square x = x * x
```

Click **Run Code** `<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" style="vertical-align: middle;"><path d="M3 2l10 6-10 6V2z"/></svg>` to make the function available in the REPL. Then test it:
```
> square 5
25
> square 12
144
```

Now add a function that uses `square` as a helper. Add this to the function panel (above or below `square`). The order of functions in the panel doesn’t matter — Haskish reads the whole panel before running your code.
```
sumOfSquares a b = square a + square b
```

Click **Run Code** <svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" style="vertical-align: middle;"><path d="M3 2l10 6-10 6V2z"/></svg> again and test:
```
> sumOfSquares 3 4
25
> sumOfSquares 5 12
169
```

Notice how `sumOfSquares` **calls** the `square` function as a helper. Breaking problems into smaller helper functions makes code easier to understand and reuse.

**~Challenge~**

Now write a complete program with helper functions:

`isRightTriangle` - Accepts three parameters (sides of a triangle) and returns `True` if they form a right-angled triangle using Pythagoras' theorem (a² + b² = c²).

You'll need these helper functions:

- `square x` - returns x squared
- `sumOfSquares a b` - returns the sum of a² and b²
- `isRightTriangle a b c` - checks if a² + b² = c²

Example:
```
> isRightTriangle 3 4 5
True
> isRightTriangle 5 12 13
True
> isRightTriangle 1 2 3
False
```

Remember: Write all three functions in the function panel, click **Run Code** `<svg width="16" height="16" viewBox="0 0 16 16" fill="currentColor" style="vertical-align: middle;"><path d="M3 2l10 6-10 6V2z"/></svg>`, then test in the REPL!

=== Building More Complex Programs ===

**~Challenge~**

Now create a more complex program with multiple helper functions.

Write a program to analyse quadratic equations (ax² + bx + c = 0). 

The **discriminant** tells us how many real solutions the equation has:

- discriminant = b² - 4ac
- If discriminant > 0, there are **two** real roots
- If discriminant = 0, there is **one** real root (repeated)
- If discriminant < 0, there are **no** real roots

Build these functions in the function panel:

`discriminant a b c` - Calculates b² - 4ac

`hasRealRoots a b c` - Returns `True` if the equation has at least one real root

`hasTwoRoots a b c` - Returns `True` if the equation has two distinct real roots

`hasOneRoot a b c` - Returns `True` if the equation has exactly one root

Think about what helper functions you might need (hint: you've written similar ones before!).

Example tests:
```
> discriminant 1 (-5) 6
1
> hasRealRoots 1 (-5) 6
True
> hasTwoRoots 1 (-5) 6
True
> hasOneRoot 2 4 2
True
> hasRealRoots 1 0 1
False
```

=== Introduction to Lists ===
**_Lists_** are collections of values of the same data type. They are enclosed in `[ ]`. Lists can be **_finite_** or **_infinite_** in length.

Try making some lists ...

```
> [45,23,9,78]
> [8..15]
> [5..]
> [3,7..50]
> [5,3..-20]
> heroes = ["superman", "spiderman", "batman"]
```
Now try the following, taking note of any **errors**:
```
> head heroes
> tail heroes
> null heroes
> "thor" : heroes
> heroes : "thor"
> extraHeroes = "thing" : heroes
> heroesAndVillains = extraHeroes ++ ["joker","magneto"]
> "kingpin" ++ heroesAndVillains
> length heroesAndVillains
```
**~Questions~**

- What does `head` do?
- What does `tail` do?
- What is the purpose of `null`?
- Describe the purpose of the cons operator `:`
- What does `++` do?
- Why does `heroes : "thor"` throw an error?
- What is wrong with `"kingpin" ++ heroesAndVillains`?

Now try the following commands, carefully noting any **errors**:
```
> take 2 heroesAndVillains
> drop 2 heroesAndVillains
> tail head heroesAndVillains
> tail [head heroesAndVillains]
> tail (head heroesAndVillains)
> head tail heroesAndVillains
> head (tail heroesAndVillains)
> heroesAndVillains !! 0
> heroesAndVillains !! 1
> heroesAndVillains !! 2
```

**~Questions~**

- What does `take` do?
- What does `drop` do?
- What is the purpose of `!!`?
- What is the problem with `tail head heroesAndVillains`?
- What does the result of `tail (head heroesAndVillains)` tell you about how strings are stored?

**~Note on Strings:~**

In Haskish (like Haskell), **String = [Char]**. This means strings are actually lists of characters!

When you write `"hello"`, it's equivalent to `['h','e','l','l','o']`

This is why you can use list functions like `head`, `tail`, `map`, and `filter` on strings, and why you can pattern match on strings with `(x:xs)`. The result of `tail (head heroesAndVillains)` demonstrates this: taking the head gives you a string, and taking the tail of that string gives you the remaining characters!

Finally try out these code snippets:
```
> length heroesAndVillains == 6
> length (tail heroesAndVillains) == 5
> (heroesAndVillains !! 1) == "thing"
> head (heroesAndVillains !! 1) == head (heroesAndVillains !! 2)
```

- Can you explain the last result?

=== Pattern Matching & Recursion ===
**_Recursion_** allows a function to call itself with a simpler version of the problem.
Every recursive function needs:

- A **_base case_** - when to stop recursing
- A **_recursive case_** - how to break down the problem

**~Example 1: Factorial~**

Factorial is defined mathematically as:

- 0! = 1 (base case)
- n! = n × (n-1)! (recursive case)

**Define the factorial function** in the function definition panel:
```
factorial 0 = 1
factorial n = n * factorial (n-1)
```

**Trace the execution:**
```
> factorial 4
= 4 * factorial 3
= 4 * 3 * factorial 2
= 4 * 3 * 2 * factorial 1
= 4 * 3 * 2 * 1 * factorial 0
= 4 * 3 * 2 * 1 * 1
= 24
```

**Try it:**
```
> factorial 5
> factorial 10
> factorial 0
```

**~Challenge~**

Now write a function `fib` that calculates the nth Fibonacci number:

```
> fib 5
5
> fib 10
55
> fib 25
75025
> fib 35
????
```

- Can you explain what happens with `fib 35`? If you look in the **Recursion Examples** in the menu, you will see an implementation `fastFib` that does not have this issue. It uses a technique called **Tail Recursion with Accumulators**. 

**~Example 2: Pattern Matching with Lists~**

**Pattern matching** lets you define functions by matching on the *structure* of data.
Lists can be matched as either `[]` (empty) or `(x:xs)` (head and tail).

The `length` function can be defined recursively:

```
calcLength [] = 0
calcLength (x:xs) = 1 + calcLength xs
```

- **Base case:** An empty list `[]` has length 0
- **Recursive case:** A list `(x:xs)` has length 1 (for head `x`) plus the length of the tail `xs`

**Trace the execution:**
```
> calcLength ['a', 'b', 'c', 'd']
= 1 + calcLength ['b', 'c', 'd']
= 1 + 1 + calcLength ['c', 'd']
= 1 + 1 + 1 + calcLength ['d']
= 1 + 1 + 1 + 1 + calcLength []
= 1 + 1 + 1 + 1 + 0
= 4
```

**Try it:**
```
> calcLength [1,2,3,4,5]
> calcLength "hello"
> calcLength []
```

**~Challenges:~** 

Write similar recursive functions:

- `sumList` - adds all numbers in a list (base: empty list = 0)
- `productList` - multiplies all numbers in a list (base: empty list = 1)
- `replicateEach` - replicates each element in a list twice (base: empty list = [], **hint:** cons the head twice onto the result of recursing on the tail)
```
> replicateEach [1,2,3]
[1,1,2,2,3,3]
> replicateEach "hi"
"hhii"
```

**~Advanced Challenges:~**

- `appendToEach` - appends a given element to the end of each sublist
```
> appendToEach 0 [[1,2],[3,4],[5]]
[[1,2,0],[3,4,0],[5,0]]
> appendToEach '!' ["hello","world"]
["hello!","world!"]
```

- `flatten` - flattens a list of lists into a single list. **Hint:** Use `++` to join the head list with the flattened tail
```
> flatten [[1,2],[3,4],[5,6]]
[1,2,3,4,5,6]
> flatten [["hello"],["world"]]
["hello","world"]
```

- `pairUp` - pairs up consecutive elements from a list. **Hint:** You need to match `(x:y:xs)` to get two elements at once
```
> pairUp [1,2,3,4,5,6]
[(1,2),(3,4),(5,6)]
> pairUp "hello"
[('h','e'),('l','l')]
```

- `countOccurrences` - counts how many times an element appears in a list. **Hint:** Match `(x:xs)`, check if `x` equals the target, then recurse. You will need to make use of the following helper function:
```
boolToInt True  = 1
boolToInt False = 0
```
In the next lesson you will see a much better way of solving this problem.
```
> countOccurrences 3 [1,3,2,3,3,4]
3
> countOccurrences 'a' "banana"
3
```

=== Guards & Conditionals ===

Haskish supports two main ways to make decisions in your code: **_Guards_** and **_Conditional expressions (if-then-else)_**.

One of the challenges from the previous exercise was to write `countOccurrences` to count how many times an element appears in a list. One way to solve this is with a helper function `boolToInt`:

```
boolToInt True  = 1
boolToInt False = 0

countOccurrences e [] = 0
countOccurrences e (x:xs) = boolToInt (e == x) + countOccurrences e xs
```

However, there are clearer ways to do this using guards or conditionals.

**_Conditional Expressions (if-then-else)_**

An `if-then-else` expression lets you choose between two values based on a condition. Both `then` and `else` branches are required because the expression must always return a value.

```
countOccurrences e [] = 0
countOccurrences e (x:xs) = if e == x then 1 + countOccurrences e xs else countOccurrences e xs
```

This is good for simple **binary choices** (one thing or another).

**_Guards_**

Guards let you test multiple conditions in sequence. Each guard starts with `|` (pipe symbol) followed by a boolean condition:

```
countOccurrences e [] = 0
countOccurrences e (x:xs)
  | e == x    = 1 + countOccurrences e xs
  | otherwise = countOccurrences e xs
```

The `otherwise` keyword is just `True` - it catches any case that doesn't match the earlier guards. Guards are especially useful when you have **multiple conditions** to check.

**When to use which:**
- **if-then-else:** Simple binary choice between two options
- **Guards:** Multiple conditions or when the logic reads more naturally as a list of cases

**~Challenges~**

Now practice using guards and if-then-else with these challenges:

- `switchBinary` - Given a list of binary digits (0s and 1s), return a new list with 0s changed to 1s and 1s changed to 0s. **Hint:** Use guards to check if `x == 0` or `x == 1`
```
> switchBinary [0,1,1,0,1]
[1,0,0,1,0]
> switchBinary [1,1,1]
[0,0,0]
```

- `countTwoElems` - Count how many times either of two given elements appear in a list. **Hint:** You'll need two guard conditions before `otherwise`
```
> countTwoElems 2 3 [1,2,3,2,4,3]
4
> countTwoElems 'a' 'e' "hello world"
1
```

- `inList` - Return `True` if a given element appears in the list, `False` otherwise
```
> inList 5 [1,3,5,7]
True
> inList 4 [1,3,5,7]
False
> inList 'x' "hello"
False
```

- `removeAll` - Remove all occurrences of a given element from a list
```
> removeAll 2 [1,2,3,2,4,2]
[1,3,4]
> removeAll 'l' "hello"
"heo"
```

- `removeFirst` - Remove only the first occurrence of a given element from a list. **Hint:** When you find the match, just return `xs` instead of recursing
```
> removeFirst 2 [1,2,3,2,4]
[1,3,2,4]
> removeFirst 'l' "hello"
"helo"
```

- `replace` - Replace all instances of one element with another element
```
> replace 2 9 [1,2,3,2,4]
[1,9,3,9,4]
> replace 'o' 'a' "hello"
"hella"
```

**~Advanced Challenges - Using Helper Functions~**

These next challenges use a common pattern: a main function that calls a helper function with an extra parameter (often called an **accumulator**) to track something as we recurse through the list.

- `multEvenIdx` - Multiply all values at even-numbered indices (0, 2, 4, ...). **Hint:** Create a helper function that takes an extra parameter `n` to track the current index
```
> multEvenIdx [1,2,3,4,5]
15
> multEvenIdx [2,10,3,10,5,10]
30
```

- `multEvenNums` - Multiply all the even numbers in a list (return 1 if there are none). **Hint:** Use the built-in `even` function
```
> multEvenNums [1,2,3,4,5,6]
48
> multEvenNums [1,3,5]
1
```

- `insertEvenPos` - Insert a given element at all even positions in a list (positions 0, 2, 4, ...). **Hint:** The pattern is `e : x : insertEvenPos e xs`
```
> insertEvenPos 0 [1,2,3]
[0,1,0,2,0,3,0]
> insertEvenPos 'x' "abc"
"xaxbxcx"
```

- `multBy` - Multiply every element in a list by a given number
```
> multBy 3 [1,2,3,4]
[3,6,9,12]
> multBy 10 [5,10,15]
[50,100,150]
```

=== Higher-Order Functions: Map, Filter, and Fold ===

In the **First-Class Functions** exercise, you wrote `applyTwice` - a function that takes another function as an argument and applies it twice:

```
> applyTwice f x = f (f x)
> double n = n * 2
> applyTwice double 3
12
```

This is an example of a **_higher-order function_** - a function that either takes functions as arguments or returns functions as results (or both!).

Higher-order functions are fundamental to functional programming. They let you write generic, reusable code that works with many different operations.

**_The Three Essential Higher-Order Functions_**

Three higher-order functions form the backbone of functional programming:

- **`map`** - transforms every element in a list
- **`filter`** - keeps only elements that satisfy a condition
- **`fold`** - combines all elements into a single result

Let's explore each one.

**_Map: Transforming Lists_**

`map` takes a function and a list, and applies that function to every element:

<div style="font-family: monospace; padding: 10px; background: #2a2a2a; border-radius: 4px; margin: 10px 0;">
map :: <span style="color: #9C27B0; font-weight: bold;">(</span><span style="color: #64B5F6">a</span> <span style="color: #9C27B0">-></span> <span style="color: #81C784">b</span><span style="color: #9C27B0; font-weight: bold;">)</span> <span style="color: #FF9800; font-weight: bold;">-></span> <span style="color: #64B5F6; font-weight: bold;">[a]</span> <span style="color: #FF9800; font-weight: bold;">-></span> <span style="color: #81C784; font-weight: bold;">[b]</span>
</div>

Think of it as: "apply this <span style="color: #9C27B0; font-weight: bold;">transformation function</span> to every item in the <span style="color: #64B5F6; font-weight: bold;">input list</span>, producing an <span style="color: #81C784; font-weight: bold;">output list</span>"

**Examples:**

```
> double x = x * 2
> map double [1,2,3,4]
[2,4,6,8]

> square x = x * x
> map square [1,2,3,4,5]
[1,4,9,16,25]

> isEven x = mod x 2 == 0
> map isEven [1,2,3,4,5,6]
[False,True,False,True,False,True]
```

Remember `multBy` from the previous exercise? It multiplied every element by a number. That's exactly what `map` does with a multiplication function:

```
> map (*3) [1,2,3,4]
[3,6,9,12]
```

Notice how we used the operator section `(*3)` directly - this is where operator sections really shine with higher-order functions!

**_Filter: Selecting Elements_**

`filter` takes a predicate (a function that returns `True` or `False`) and a list, keeping only elements where the predicate is `True`:

<div style="font-family: monospace; padding: 10px; background: #2a2a2a; border-radius: 4px; margin: 10px 0;">
filter :: <span style="color: #9C27B0; font-weight: bold;">(</span><span style="color: #64B5F6">a</span> <span style="color: #9C27B0">-></span> <span style="color: #FFB74D">Bool</span><span style="color: #9C27B0; font-weight: bold;">)</span> <span style="color: #FF9800; font-weight: bold;">-></span> <span style="color: #64B5F6; font-weight: bold;">[a]</span> <span style="color: #FF9800; font-weight: bold;">-></span> <span style="color: #64B5F6; font-weight: bold;">[a]</span>
</div>

Think of it as: "keep only the items from the <span style="color: #64B5F6; font-weight: bold;">input list</span> that pass the <span style="color: #9C27B0; font-weight: bold;">predicate test</span>"

**Examples:**

```
> isEven x = mod x 2 == 0
> filter isEven [1,2,3,4,5,6]
[2,4,6]

> isPositive x = x > 0
> filter isPositive [-3,-1,0,2,5,-7,8]
[2,5,8]

> filter (>5) [1,3,6,2,8,4,9]
[6,8,9]

> filter (=="cat") ["dog","cat","bird","cat","fish"]
["cat","cat"]
```

**_Fold: Combining Elements_**

`fold` takes a combining function, an initial value, and a list, then combines all elements into a single result:

<div style="font-family: monospace; padding: 10px; background: #2a2a2a; border-radius: 4px; margin: 10px 0;">
fold :: <span style="color: #9C27B0; font-weight: bold;">(</span><span style="color: #F48FB1">b</span> <span style="color: #9C27B0">-></span> <span style="color: #64B5F6">a</span> <span style="color: #9C27B0">-></span> <span style="color: #F48FB1">b</span><span style="color: #9C27B0; font-weight: bold;">)</span> <span style="color: #FF9800; font-weight: bold;">-></span> <span style="color: #F48FB1; font-weight: bold;">b</span> <span style="color: #FF9800; font-weight: bold;">-></span> <span style="color: #64B5F6; font-weight: bold;">[a]</span> <span style="color: #FF9800; font-weight: bold;">-></span> <span style="color: #F48FB1; font-weight: bold;">b</span>
</div>

Think of it as: "combine all items from the <span style="color: #64B5F6; font-weight: bold;">input list</span> using the <span style="color: #9C27B0; font-weight: bold;">combining function</span>, starting with the <span style="color: #F48FB1; font-weight: bold;">initial accumulator</span>, producing a <span style="color: #F48FB1; font-weight: bold;">final result</span>"

The combining function takes two arguments:

1. The **accumulator** (the result so far)

2. The **current element** from the list

**Examples:**

```
> add x y = x + y
> fold add 0 [1,2,3,4]
10

> multiply x y = x * y
> fold multiply 1 [2,3,4]
24

> fold (+) 0 [1,2,3,4,5]
15

> fold (*) 1 [1,2,3,4,5]
120

> fold max 0 [3,7,2,9,4]
9
```

Let's trace `fold (+) 0 [1,2,3]`:

1. Start with `0` (the initial value)

2. `0 + 1 = 1`

3. `1 + 2 = 3`

4. `3 + 3 = 6`

5. Result: `6`

**_Combining Map, Filter, and Fold_**

The real power comes from combining these functions:

```
> fold (+) 0 (map (*2) [1,2,3,4])
20
```

This doubles each number `[2,4,6,8]` then sums them `2+4+6+8 = 20`

```
> fold (+) 0 (filter (>3) [1,2,3,4,5,6])
15
```

This keeps numbers greater than 3 `[4,5,6]` then sums them `4+5+6 = 15`

```
> map (*2) (filter isEven [1,2,3,4,5,6])
[4,8,12]
```

This keeps even numbers `[2,4,6]` then doubles them `[4,8,12]`

**~Challenges:~**

**~Map Challenges:~**

- Use `map` to convert a list of temperatures from Fahrenheit to Celsius using the formula: `C = (F - 32) * 5 / 9`
```
> map fahrenheitToCelsius [32,50,68,86,104]
[0,10,20,30,40]
```

- Use `map` to add an exclamation mark to the end of each string in a list. **Hint:** Use the `(++ "!")` operator section
```
> map ... ["Hello","Goodbye","Welcome"]
["Hello!","Goodbye!","Welcome!"]
```

- Use `map` to get the first character of each string in a list
```
> map ... ["apple","banana","cherry"]
"abc"
```

**~Filter Challenges:~**

- Use `filter` to keep only numbers greater than 10
```
> filter ... [5,15,3,20,8,25]
[15,20,25]
```

- Use `filter` to keep only strings that start with the letter 'a'. **Hint:** Define a helper function that checks if `head s == 'a'`
```
> filter ... ["apple","banana","apricot","cherry"]
["apple","apricot"]
```

- Use `filter` to keep only the odd numbers from a list. **Hint:** You'll need a helper function to check if a number is odd
```
> filter ... [1,2,3,4,5,6,7,8,9,10]
[1,3,5,7,9]
```

**~Fold Challenges:~**

- Use `fold` to find the sum of all even numbers from 1 to 10. **Hint:** First filter for even numbers, then fold with addition
```
> fold ... (filter ... [1,2,3,4,5,6,7,8,9,10])
30
```

- Use `fold` to concatenate a list of strings with the `++` operator
```
> fold ... ["Hello"," ","World","!"]
"Hello World!"
```

- Use `fold` to count how many elements are in a list. **Hint:** The combining function should ignore the current element and just add 1 to the accumulator
```
> fold ... [10,20,30,40,50]
5
```

**~Combined Challenges:~**

- Get the sum of squares of all even numbers in a list
```
> square x = x * x
> fold ... (map ... (filter ... [1,2,3,4,5,6]))
56
```
Because: even numbers are `[2,4,6]`, squares are `[4,16,36]`, sum is `4+16+36 = 56`

- Double all numbers greater than 5, then find their product
```
> fold ... (map ... (filter ... [3,6,2,8,4,10]))
3840
```
Because: numbers > 5 are `[6,8,10]`, doubled are `[12,16,20]`, product is `12*16*20 = 3840`

- Extract the length of each string, then sum the lengths
```
> fold ... (map ... ["hello","world","functional"])
20
```

**_Why This Matters_**

Higher-order functions like `map`, `filter`, and `fold` are the foundation of functional programming because they:

- **Eliminate explicit recursion** - you don't need to write recursive functions for common patterns
- **Express intent clearly** - `map square` is clearer than a recursive function that squares elements
- **Compose beautifully** - you can chain them together to build complex transformations
- **Are proven correct** - unlike hand-written recursion, these functions are well-tested
- **Enable parallel processing** - operations like `map` can potentially run on multiple cores

These patterns appear in all functional languages (Haskell, Scala, Clojure, etc.) and even in modern JavaScript, Python, and other languages. Mastering them makes you a better programmer in any language!

=== List Comprehensions ===

In mathematics, you've probably seen **_set-builder notation_** - a concise way to define sets:

```
{ x² | x ∈ ℕ, x < 10 }
```

This reads as: "the set of all x² such that x is a natural number and x is less than 10", which gives us `{0, 1, 4, 9, 16, 25, 36, 49, 64, 81}`

**_List comprehensions_** in Haskish use almost identical syntax to describe lists. They provide a clear, concise way to create and transform lists that closely mirrors mathematical notation.

**_Basic Syntax_**

The general form of a list comprehension is:

```
[ expression | variable <- list ]
```

Think of it as: "create a list by evaluating **expression** for each **variable** drawn from **list**"

Let's see how the mathematical set notation translates to Haskish:

**Mathematics:**
```
{ x² | x ∈ {1,2,3,4,5} }
```

**Haskish:**
```
> [x * x | x <- [1,2,3,4,5]]
[1,4,9,16,25]
```

The `|` symbol means "such that" (just like in mathematics), and `<-` means "drawn from".

**More Examples:**

```
> [x * 2 | x <- [1,2,3,4]]
[2,4,6,8]

> [x + 10 | x <- [1,2,3]]
[11,12,13]

> isEven x = mod x 2 == 0
> [isEven x | x <- [1,2,3,4,5,6]]
[False,True,False,True,False,True]
```

Notice how this is similar to using `map`:

```
> map (*2) [1,2,3,4]
[2,4,6,8]
```

But list comprehensions can do much more!

**_Adding Predicates (Filters)_**

In mathematics, we often add conditions to set-builder notation:

**Mathematics:**
```
{ x² | x ∈ ℕ, x < 10, x is even }
```

**Haskish:**
```
> [x * x | x <- [0..9], mod x 2 == 0]
[0,4,16,36,64]
```

The part after the first condition (`mod x 2 == 0`) is called a **_predicate_** or **_guard_**. You can have multiple predicates separated by commas:

```
> [x | x <- [1..20], mod x 2 == 0, x > 10]
[12,14,16,18,20]
```

This keeps only numbers that are even AND greater than 10.

**More Examples:**

```
> [x | x <- [1..10], mod x 2 /= 0]
[1,3,5,7,9]

> [x * 2 | x <- [1..10], x > 5]
[12,14,16,18,20]

> [c | c <- "Hello World", c /= 'o']
"Hell Wrld"
```

This is similar to combining `filter` and `map`:

```
> map (*2) (filter (>5) [1..10])
[12,14,16,18,20]
```

But the list comprehension syntax is often more readable!

**_Multiple Generators_**

List comprehensions can draw from multiple lists, creating combinations:

**Mathematics:**
```
{ (x,y) | x ∈ {1,2,3}, y ∈ {4,5} }
```

**Haskish:**
```
> [(x,y) | x <- [1,2,3], y <- [4,5]]
[(1,4),(1,5),(2,4),(2,5),(3,4),(3,5)]
```

The order matters! The rightmost generator varies fastest (like nested loops in other languages).

```
> [(x,y) | x <- [1,2], y <- [3,4]]
[(1,3),(1,4),(2,3),(2,4)]

> [x + y | x <- [1,2,3], y <- [10,20]]
[11,21,12,22,13,23]

> [x * y | x <- [2,3], y <- [4,5]]
[8,10,12,15]
```

You can also use earlier generators in later ones:

```
> [(x,y) | x <- [1..3], y <- [x..3]]
[(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
```

This creates pairs where the second element is greater than or equal to the first!

**_Combining with Predicates_**

You can use multiple generators AND predicates together:

```
> [(x,y) | x <- [1..5], y <- [1..5], x + y == 7]
[(2,5),(3,4),(4,3),(5,2)]
```

This finds all pairs that sum to 7.

```
> [(x,y) | x <- [1..10], y <- [1..10], x < y, mod x 2 == 0, mod y 2 /= 0]
[(2,3),(2,5),(2,7),(2,9),(4,5),(4,7),(4,9),(6,7),(6,9),(8,9)]
```

This finds pairs where x < y, x is even, and y is odd.

**_String Comprehensions_**

Remember that in Haskish (and Haskell), **String = [Char]** - strings are lists of characters! This means comprehensions work on them too:

```
> [c | c <- "Hello World", c /= ' ']
"HelloWorld"

> isVowel c = c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'
> [c | c <- "functional", isVowel c]
"uioa"

> [[c] | c <- "HELLO"]
["H","E","L","L","O"]
```

Notice that when we iterate over `"HELLO"`, each element `c` is a single character (`'H'`, `'E'`, etc.). In the last example, `[c]` wraps each character in a one-element list, creating a list of strings.

**~Challenges:~**

**~Basic Comprehensions:~**

- Create a list of the first 10 perfect squares (1, 4, 9, 16, ...)
```
> [... | x <- [1..10]]
[1,4,9,16,25,36,49,64,81,100]
```

- Create a list that adds 5 to every number from 1 to 8
```
> [... | x <- [1..8]]
[6,7,8,9,10,11,12,13]
```

- Create a list of all numbers from 1 to 20 that are divisible by 3. **Hint:** Use `mod x 3 == 0`
```
> [x | x <- [1..20], ...]
[3,6,9,12,15,18]
```

**~Comprehensions with Predicates:~**

- Create a list of all even numbers from 1 to 20, then square each one
```
> [... | x <- [1..20], mod x 2 == 0]
[4,16,36,64,100,144,196,256,324,400]
```

- Create a list of all numbers from 1 to 50 that are divisible by both 3 and 5
```
> [x | x <- [1..50], ...]
[15,30,45]
```

- Extract all lowercase vowels from the string "Functional Programming"
```
> isVowel c = c == 'a' || c == 'e' || c == 'i' || c == 'o' || c == 'u'
> [c | c <- "Functional Programming", ...]
"uioaoi"
```

**~Multiple Generators:~**

- Create a multiplication table: all products of x and y where both x and y range from 1 to 5
```
> [x * y | ...]
[1,2,3,4,5,2,4,6,8,10,3,6,9,12,15,4,8,12,16,20,5,10,15,20,25]
```

- Create all possible pairs of a number from `[1,2,3]` and a letter from `"abc"`
```
> [(x,y) | ...]
[(1,'a'),(1,'b'),(1,'c'),(2,'a'),(2,'b'),(2,'c'),(3,'a'),(3,'b'),(3,'c')]
```

- Generate all Pythagorean triples (a,b,c) where a² + b² = c² and all values are between 1 and 20. **Hint:** Use three generators and a predicate checking `a*a + b*b == c*c`
```
> [(a,b,c) | a <- [1..20], b <- [1..20], c <- [1..20], a*a + b*b == c*c]
[(3,4,5),(4,3,5),(5,12,13),(6,8,10),(8,6,10),(8,15,17),(9,12,15),(12,5,13),(12,9,15),(15,8,17)]
```

**~Advanced Challenges:~**

For these challenges, you'll need a `sum` function. Define it first:
```
> sum xs = fold (+) 0 xs
```

- Generate the first 10 triangular numbers (1, 3, 6, 10, 15, ...) where the nth triangular number is the sum of integers from 1 to n. **Hint:** Use `sum [1..n]`
```
> [sum [1..n] | ...]
[1,3,6,10,15,21,28,36,45,55]
```

- Create a "flattened" list from a list of lists, but only including sublists that have more than 2 elements. **Hint:** Use a predicate `length xs > 2` and concatenate with `++`
```
> flatten xss = [x | xs <- xss, length xs > 2, x <- xs]
> flatten [[1],[2,3],[4,5,6],[7,8,9,10]]
[4,5,6,7,8,9,10]
```

- Find all perfect numbers from 1 to 100. A perfect number equals the sum of its proper divisors (divisors less than itself). **Hint:** You'll need a `divisors` function to find all divisors of n less than n, a `sum` function, and an `isPerfect` function to check if the sum of divisors equals n
```
> [n | n <- [1..100], ...]
[6,28]
```

**_List Comprehensions vs Map/Filter/Fold_**

You might notice that list comprehensions can replace many uses of `map` and `filter`:

**Transform:**
- Using map/filter: `map (*2) [1..5]`
- Using comprehension: `[x*2 | x <- [1..5]]`

**Filter:**
- Using map/filter: `filter (\x -> mod x 2 == 0) [1..10]`
- Using comprehension: `[x | x <- [1..10], mod x 2 == 0]`

**Both (filter + transform):**
- Using map/filter: `map (*2) (filter (\x -> mod x 2 == 0) [1..10])`
- Using comprehension: `[x*2 | x <- [1..10], mod x 2 == 0]`

Choose based on readability:
- **List comprehensions** are great when you want a concise, mathematical expression
- **map/filter** are better when you already have named functions or are building pipelines with composition
- **fold** is still needed when you want to combine elements into a single result

**_Why This Matters_**

List comprehensions are powerful because they:

- **Mirror mathematical notation** - making code easier to understand for those with math background
- **Are concise** - express complex list operations in a single, readable line
- **Combine filtering and mapping** - no need to chain multiple operations
- **Support multiple generators** - naturally express combinations and nested iterations
- **Are optimised** - the compiler can often optimise comprehensions better than explicit recursion

List comprehensions appear in Python, Haskell, Scala, and other modern languages. They're one of the most elegant features borrowed from mathematics into programming!

=== Tuples and Destructuring ===

In functional programming, **_tuples_** are fixed-size collections that can hold values of different types. Unlike lists (which have variable length and all elements must be the same type), tuples have a fixed number of elements that can each be of different types.

**_Creating Tuples_**

Tuples are created using parentheses and commas:

```
> (1, 2)
(1,2)

> ("Alice", 25, True)
("Alice",25,True)

> ('x', "hello", 42)
('x',"hello",42)
```

The most common tuples are **_pairs_** (2 elements) and **_triples_** (3 elements):

```
> pair = (10, 20)
> triple = ("John", 30, 175.5)
> coordinate = (45.5, -122.6)
```

**_Why Use Tuples?_**

Tuples are useful when you want to:
- **Return multiple values** from a function
- **Group related data** temporarily without defining a new type
- **Represent fixed structures** like coordinates, key-value pairs, or records

**_Pattern Matching with Tuples (Destructuring)_**

The most powerful way to work with tuples is **_pattern matching_** (also called **_destructuring_**). This lets you extract all elements at once:

```
> addPair (x, y) = x + y
> addPair (3, 5)
8

> fullName (first, last) = first ++ " " ++ last
> fullName ("Ada", "Lovelace")
"Ada Lovelace"
```

Notice how `(x, y)` in the function definition matches the structure of the input tuple and binds `x` to the first element and `y` to the second.

**_Destructuring Triples and Larger Tuples_**

You can pattern match on tuples of any size:

```
> addTriple (x, y, z) = x + y + z
> addTriple (10, 20, 30)
60

> getMiddle (a, b, c) = b
> getMiddle (1, 2, 3)
2

> describe (name, age) = name ++ " is a person"
> describe ("Bob", 42)
"Bob is a person"
```

**_Nested Tuples_**

Tuples can contain other tuples, and you can destructure them too:

```
> addPairs ((a, b), (c, d)) = (a + c, b + d)
> addPairs ((1, 2), (3, 4))
(4,6)

> swapNested ((a, b), c) = ((b, a), c)
> swapNested ((1, 2), 3)
((2,1),3)
```

**_Tuples in Lists_**

You can have lists of tuples, which is extremely useful:

```
> pairs = [(1, 2), (3, 4), (5, 6)]
> head pairs
(1,2)

> firstElements xs = [x | (x, y) <- xs]
> firstElements [(1, 2), (3, 4), (5, 6)]
[1,3,5]

> sumPairs xs = [x + y | (x, y) <- xs]
> sumPairs [(1, 2), (3, 4), (5, 6)]
[3,7,11]
```

Notice how `(x, y) <- xs` destructures each pair in the list!

**_Processing Lists of Pairs_**

```
> multiplyPairs xs = [x * y | (x, y) <- xs]
> multiplyPairs [(2, 3), (4, 5), (6, 7)]
[6,20,42]

> swapPairs xs = [(y, x) | (x, y) <- xs]
> swapPairs [(1, 2), (3, 4)]
[(2,1),(4,3)]
```

**_Using Tuples with Map and Fold_**

Tuples work well with higher-order functions. You can define helper functions to extract elements:

```
> fst (x, y) = x
> snd (x, y) = y
> map fst [(1, 2), (3, 4), (5, 6)]
[1,3,5]

> map snd [(1, 2), (3, 4), (5, 6)]
[2,4,6]

> sumFirsts xs = fold (+) 0 (map fst xs)
> sumFirsts [(1, 10), (2, 20), (3, 30)]
6
```

**~Challenges:~**

**~Basic Tuple Operations:~**

- Write `fst` that returns the first element of a pair
```
> fst (10, 20)
10
> fst ("Alice", 25)
"Alice"
```

- Write `snd` that returns the second element of a pair
```
> snd (10, 20)
20
> snd ("Alice", 25)
25
```

- Write `swap` that swaps the elements of a pair
```
> swap (1, 2)
(2,1)
> swap ("hello", "world")
("world","hello")
```

- Write `both` that applies a function to both elements of a pair
```
> both (*2) (3, 5)
(6,10)
> both (++ "!") ("hello", "world")
("hello!","world!")
```

- Write `first` that applies a function to only the first element of a pair
```
> first (*2) (3, 5)
(6,5)
> first (++ "!") ("hello", "world")
("hello!","world")
```

- Write `second` that applies a function to only the second element of a pair
```
> second (*2) (3, 5)
(3,10)
> second (++ "!") ("hello", "world")
("hello","world!")
```

**~Working with Triples:~**

- Write `getFirst` that returns the first element of a triple
```
> getFirst (1, 2, 3)
1
> getFirst ("Alice", 25, True)
"Alice"
```

- Write `getThird` that returns the third element of a triple
```
> getThird (1, 2, 3)
3
> getThird ("Alice", 25, True)
True
```

- Write `rotateTriple` that rotates elements: (a,b,c) becomes (b,c,a)
```
> rotateTriple (1, 2, 3)
(2,3,1)
> rotateTriple ("x", "y", "z")
("y","z","x")
```

**~List of Tuples Challenges:~**

- Write `sumPairList` that sums the elements in each pair and returns a list of sums
```
> sumPairList [(1, 2), (3, 4), (5, 6)]
[3,7,11]
> sumPairList [(10, 20), (30, 40)]
[30,70]
```

- Write `filterByFirst` that keeps only pairs where the first element is greater than a given value
```
> filterByFirst 5 [(3, 10), (7, 20), (2, 30), (8, 40)]
[(7,20),(8,40)]
> filterByFirst 0 [(-1, 5), (2, 10), (-3, 15)]
[(2,10)]
```

- Write `maxPair` that returns the maximum of each pair
```
> maxPairs [(3, 7), (10, 5), (8, 12)]
[7,10,12]
> maxPairs [(1, 1), (5, 3)]
[1,5]
```

- Write `zip` that takes two lists and returns a list of pairs, combining corresponding elements (stop when either list runs out)
```
> zip [1, 2, 3] [4, 5, 6]
[(1,4),(2,5),(3,6)]
> zip "abc" [1, 2, 3]
[('a',1),('b',2),('c',3)]
> zip [1, 2] [10, 20, 30, 40]
[(1,10),(2,20)]
```
**Hint:** Use pattern matching with `(x:xs)` and `(y:ys)`, base case is when either list is empty

- Write `unzip` that separates a list of pairs into two lists (this is the opposite of `zip`)
```
> unzip [(1, 4), (2, 5), (3, 6)]
([1,2,3],[4,5,6])
> unzip [('a', 1), ('b', 2), ('c', 3)]
("abc",[1,2,3])
```
**Hint:** Use two list comprehensions to extract firsts and seconds separately, or use recursion to build both lists

**~Advanced Challenges:~**

For these challenges, you'll need a `sum` function. Define it first:
```
> sum xs = fold (+) 0 xs
```

- Write `dotProduct` that computes the dot product of two vectors (represented as lists). The dot product is the sum of the products of corresponding elements. **Hint:** First implement `zip` (from above), then use it to pair up elements, multiply and sum
```
> dotProduct [1, 2, 3] [4, 5, 6]
32
> dotProduct [2, 3] [4, 5]
23
```
Because: `1*4 + 2*5 + 3*6 = 4 + 10 + 18 = 32` and `2*4 + 3*5 = 8 + 15 = 23`

- Write `zipWith` that takes a function and two lists, and combines them element-wise using that function
```
> zipWith (+) [1, 2, 3] [4, 5, 6]
[5,7,9]
> zipWith (*) [2, 3, 4] [5, 6, 7]
[10,18,28]
> zipWith max [1, 5, 3] [4, 2, 6]
[4,5,6]
```
**Hint:** First `zip` the lists (using your `zip` function from above), then `map` the function over pairs

- Write `enumerate` that pairs each element with its index (starting from 0)
```
> enumerate ["apple", "banana", "cherry"]
[(0,"apple"),(1,"banana"),(2,"cherry")]
> enumerate [10, 20, 30]
[(0,10),(1,20),(2,30)]
```
**Hint:** Use a helper function with an accumulator to track the index, or use your `zip` function with an infinite list `[0..]`

- Write `splitAt` that takes a number n and a list, and returns a pair of lists: the first n elements and the remaining elements
```
> splitAt 2 [1, 2, 3, 4, 5]
([1,2],[3,4,5])
> splitAt 3 "hello"
("hel","lo")
```

**~Tuples with Pattern Matching in Recursion:~**

- Write `pairwiseSum` that takes two lists and returns a list of their pairwise sums (stop when either list runs out)
```
> pairwiseSum [1, 2, 3] [4, 5, 6]
[5,7,9]
> pairwiseSum [1, 2] [10, 20, 30, 40]
[11,22]
```
**Hint:** Use pattern matching with `(x:xs)` and `(y:ys)`, and handle the base cases

- Write `mergeAlternate` that merges two lists by alternating elements
```
> mergeAlternate [1, 2, 3] [10, 20, 30]
[1,10,2,20,3,30]
> mergeAlternate "abc" "123"
"a1b2c3"
```

**_Why This Matters_**

Tuples and destructuring are fundamental to functional programming because they:

- **Allow multiple return values** - functions can return complex data without defining custom types
- **Enable elegant pattern matching** - destructure data exactly where you use it
- **Provide type safety** - tuples of different sizes are different types
- **Simplify data processing** - combine with `map` and comprehensions for powerful transformations
- **Express mathematical concepts** - coordinates, points, pairs, relations are all naturally tuples

Mastering tuples and destructuring will make your code more concise and expressive. Combined with pattern matching, they form one of the most elegant features of functional programming!

=== Lambda Functions ===

You've seen **_lambda functions_** (also called **_anonymous functions_**) mentioned briefly before. Now it's time to explore them in depth.

**_What is a Lambda Function?_**

A lambda function is a function without a name. You create it on the spot when you need it, use it, and don't save it for later. Think of it as a "disposable" function.

**_Lambda Syntax_**

In Haskish, lambda functions use the backslash `\` (which looks like the Greek letter λ "lambda"):

```
\parameter -> expression
```

The `\` starts the lambda, followed by the parameter(s), then `->`, then the expression that becomes the result.

**Basic Examples:**

```
> (\x -> x * 2) 5
10

> (\x -> x + 10) 7
17

> (\s -> s ++ "!") "hello"
"hello!"
```

Notice how we put the lambda in parentheses `(\x -> x * 2)` and then apply it to an argument.

Lambdas are also commonly used with higher-order functions like `map`:

```
> map (\x -> x * 2) [1,2,3]
[2,4,6]

> map (\s -> s ++ "!") ["hello", "world"]
["hello!","world!"]
```

**_Multiple Parameters_**

Lambda functions can take multiple parameters:

```
> add = \x y -> x + y
> add 3 5
8

> calculate = \a b c -> a * b + c
> calculate 2 3 4
10

> combine = \x y -> x ++ " and " ++ y
> combine "cats" "dogs"
"cats and dogs"
```

**_Why Use Lambda Functions?_**

Lambda functions are useful when:

1. **You need a simple function only once** - no need to give it a name
2. **The function is too trivial to name** - naming it might make code less clear
3. **You're passing a function as an argument** - especially with `map`, `filter`, `fold`

**_Lambdas with Map_**

Instead of defining a named function, you can use a lambda directly:

**With named function:**
```
> double x = x * 2
> map double [1,2,3,4]
[2,4,6,8]
```

**With lambda:**
```
> map (\x -> x * 2) [1,2,3,4]
[2,4,6,8]
```

More examples:
```
> map (\x -> x + 1) [1,2,3,4,5]
[2,3,4,5,6]

> map (\x -> x * x) [1,2,3,4]
[1,4,9,16]

> map (\s -> s ++ "!") ["hello", "world"]
["hello!","world!"]

> map (\x -> x * 2 + 1) [1,2,3]
[3,5,7]
```

**_Lambdas with Filter_**

Lambdas are perfect for quick predicates:

```
> filter (\x -> x > 5) [1,3,7,2,9,4]
[7,9]

> filter (\x -> mod x 2 == 0) [1,2,3,4,5,6]
[2,4,6]

> filter (\s -> head s == 'a') ["apple", "banana", "apricot"]
["apple","apricot"]

> filter (\x -> x /= ' ') "hello world"
"helloworld"
```

**_Lambdas with Fold_**

```
> fold (\acc x -> acc + x) 0 [1,2,3,4]
10

> fold (\acc x -> acc * x) 1 [1,2,3,4]
24

> fold (\acc x -> x : acc) [] [1,2,3]
[3,2,1]
```

The last example reverses a list! The accumulator starts as `[]`, and we cons each element onto the front.

**_Combining Map, Filter, and Lambdas_**

```
> map (\x -> x * 2) (filter (\x -> x > 3) [1,2,3,4,5,6])
[8,10,12]

> fold (\acc x -> acc + x) 0 (map (\x -> x * x) [1,2,3,4])
30
```

The second example squares `[1,4,9,16]` then sums them `= 30`

**_Lambdas in List Comprehensions_**

You can use lambdas inside list comprehensions too:

```
> [(\x -> x * 2) y | y <- [1,2,3,4]]
[2,4,6,8]

> map (\(x,y) -> x + y) [(1,2), (3,4), (5,6)]
[3,7,11]
```

The second example uses a lambda with pattern matching on tuples!

**_Returning Lambda Functions_**

Functions can return lambda functions:

```
> makeAdder n = \x -> x + n
> addTen = makeAdder 10
> addTen 5
15

> makeMultiplier m = \x -> x * m
> triple = makeMultiplier 3
> triple 7
21
```

This is what you saw earlier in the "First-Class Functions" exercise!

**_Lambdas vs Named Functions_**

**When to use lambdas:**
- Simple, one-time use functions
- Very short operations (like `\x -> x * 2`)
- Inline with `map`, `filter`, `fold`

**When to use named functions:**
- Complex logic that's hard to read in one line
- Functions you'll use multiple times
- Functions that deserve a descriptive name for clarity

**Compare:**

```
> map (\x -> x * 2 + 1) [1,2,3]
[3,5,7]
```

vs

```
> doubleAndAddOne x = x * 2 + 1
> map doubleAndAddOne [1,2,3]
[3,5,7]
```

The lambda is fine for simple cases. The named function is better if the logic is used elsewhere or is complex.

**_Operator Sections vs Lambdas_**

Sometimes operator sections are clearer than lambdas:

```
> map (\x -> x * 2) [1,2,3]
[2,4,6]

> map (*2) [1,2,3]
[2,4,6]
```

The operator section `(*2)` is more concise! But lambdas are more flexible:

```
> map (\x -> 2 * x + 1) [1,2,3]
[3,5,7]
```

You can't express this with a simple operator section.

**~Challenges:~**

**~Basic Lambda Challenges:~**

- Use a lambda with `map` to convert a list of numbers to their negatives
```
> map (\x -> ...) [1,2,3,4,5]
[-1,-2,-3,-4,-5]
```

- Use a lambda with `filter` to keep only strings longer than 3 characters. **Hint:** Use `length`
```
> filter (\s -> ...) ["hi", "hello", "bye", "world"]
["hello","world"]
```

- Use a lambda with `map` to extract the second element from each pair
```
> map (\p -> ...) [(1,2), (3,4), (5,6)]
[2,4,6]
```

- Use a lambda with `fold` to multiply all numbers in a list
```
> fold (\acc x -> ...) 1 [2,3,4]
24
```

**~Intermediate Challenges:~**

- Use `map` with a lambda to add 10 to numbers greater than 5, but keep numbers 5 or less unchanged. **Hint:** Use `if-then-else` inside the lambda
```
> map (\x -> ...) [1,3,6,8,2,9]
[1,3,16,18,2,19]
```

- Use `filter` with a lambda to keep only pairs where the first element is less than the second
```
> filter (\p -> ...) [(1,2), (5,3), (2,8), (4,4)]
[(1,2),(2,8)]
```

- Write a function `applyTwice` that takes a function and a value, and applies the function twice. Test it with a lambda
```
> applyTwice f x = ...
> applyTwice (\x -> x * 2) 3
12
> applyTwice (\x -> x ++ "!") "hi"
"hi!!"
```

- Use `map` with a lambda that takes a pair and returns a pair with the elements swapped
```
> map (\pair -> ...) [(1,2), (3,4), (5,6)]
[(2,1),(4,3),(6,5)]
```

**~Advanced Challenges:~**

- Use `fold` with a lambda to reverse a list
```
> fold (\acc x -> ...) [] [1,2,3,4]
[4,3,2,1]
```

- Write `filterMap` that filters a list with one lambda and then maps another lambda over the result
```
> filterMap predicate transform xs = ...
> filterMap (\x -> x > 2) (\x -> x * 10) [1,2,3,4,5]
[30,40,50]
```

- Use `map` with a lambda to apply different functions to odd and even numbers: multiply odd by 3, even by 2
```
> map (\x -> ...) [1,2,3,4,5]
[3,4,9,8,15]
```

- Write `compose` that takes two functions and returns a lambda that applies them in sequence (function composition using lambdas)
```
> compose f g = ...
> double x = x * 2
> addOne x = x + 1
> doubleThenAdd = compose addOne double
> doubleThenAdd 5
11
```

- Use `fold` with a lambda to find the maximum element in a list (assume non-empty list)
```
> fold (\acc x -> ...) (head [3,7,2,9,1]) (tail [3,7,2,9,1])
9
```

**~Combining Everything:~**

- Write `sumOfSquaresOfEvens` using only lambdas with `map`, `filter`, and `fold`
```
> sumOfSquaresOfEvens xs = ...
> sumOfSquaresOfEvens [1,2,3,4,5,6]
56
```
Because: evens are `[2,4,6]`, squares are `[4,16,36]`, sum is `56`

- Use lambdas to extract all second elements from a list of pairs, double them, keep only those greater than 10, and sum them
```
> processData xs = ...
> processData [(1,5), (2,7), (3,9)]
32
```
Because: seconds are `[5,7,9]`, doubled `[10,14,18]`, greater than 10 `[14,18]`, sum `32`

- Create a function that takes a list of numbers and returns a list of strings, where even numbers become "EVEN" and odd numbers become "ODD". Use only a lambda with `map`
```
> map (\x -> if ... then ... else ...) [1,2,3,4,5]
["ODD","EVEN","ODD","EVEN","ODD"]
```

**_Why This Matters_**

Lambda functions are essential in functional programming because they:

- **Reduce boilerplate** - no need to name every tiny function
- **Enable inline logic** - keep related code together
- **Support functional composition** - pass functions around naturally
- **Make code concise** - especially with `map`, `filter`, and `fold`
- **Are fundamental** - many functional patterns rely on lambdas

Every modern programming language has adopted lambda functions (Python, JavaScript, Java, C#, Ruby, etc.) because they're so useful. In functional languages like Haskish and Haskell, they're absolutely essential!

Mastering lambdas lets you write elegant, concise code. Combined with higher-order functions, they give you incredible expressive power!

