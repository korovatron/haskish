-- HASKISH COMPREHENSIVE FEATURE REFERENCE
-- Copy and paste these functions to explore all available features
-- After running, test them in the REPL

-- ============================================
-- BASIC FUNCTIONS
-- ============================================

double x = x * 2
triple x = 3 * x
add x y = x + y
multiply x y = x * y

-- Implicit multiplication (3x becomes 3*x)
timesThree x = 3x
formula x = 2x + 5


-- ============================================
-- PATTERN MATCHING ON VALUES
-- ============================================

factorial 0 = 1
factorial 1 = 1
factorial n = n * factorial (n - 1)

fib 0 = 0
fib 1 = 1
fib n = fib (n-1) + fib (n-2)

isZero 0 = True
isZero n = False


-- ============================================
-- GUARDS (CONDITIONAL LOGIC)
-- ============================================

absolute n
  | n < 0     = -n
  | otherwise = n

sign n
  | n > 0     = 1
  | n < 0     = -1
  | otherwise = 0

classify n
  | n < 0     = "negative"
  | n == 0    = "zero"
  | n > 0     = "positive"

grade score
  | score >= 90 = "A"
  | score >= 80 = "B"
  | score >= 70 = "C"
  | score >= 60 = "D"
  | otherwise   = "F"


-- ============================================
-- LIST PATTERN MATCHING
-- ============================================

myLength [] = 0
myLength (x:xs) = 1 + myLength xs

myHead (x:xs) = x
myTail (x:xs) = xs

firstTwo (x:y:xs) = [x, y]
sumTwo [x, y] = x + y

safeHead [] = error "Empty list!"
safeHead (x:xs) = x


-- ============================================
-- RECURSION WITH LISTS
-- ============================================

doubleAll [] = []
doubleAll (x:xs) = (2*x) : doubleAll xs

positives [] = []
positives (x:xs)
  | x > 0     = x : positives xs
  | otherwise = positives xs

sumList [] = 0
sumList (x:xs) = x + sumList xs

productList [] = 1
productList (x:xs) = x * productList xs

maximum [x] = x
maximum (x:xs)
  | x > maximum xs = x
  | otherwise      = maximum xs

reverse [] = []
reverse (x:xs) = reverse xs ++ [x]


-- ============================================
-- TUPLES
-- ============================================

-- Tuple creation
point = (3, 5)
threeTuple = (1, 2, 3)
nested = ((1, 2), (3, 4))

-- Tuple pattern matching
fst (x, y) = x
snd (x, y) = y
swap (x, y) = (y, x)
addPair (x, y) = x + y

-- Multiple tuple parameters
distance (x1, y1) (x2, y2) = ((x2-x1)*(x2-x1) + (y2-y1)*(y2-y1))

comparePoints (x1, y1) (x2, y2)
  | x1 > x2 && y1 > y2 = "first dominates"
  | x1 < x2 && y1 < y2 = "second dominates"
  | x1 == x2 && y1 == y2 = "equal"
  | otherwise = "incomparable"

-- Lists of tuples
points = [(0,0), (1,1), (2,4), (3,9)]

sumPairs [] = []
sumPairs ((x,y):rest) = (x+y) : sumPairs rest

firstCoords [] = []
firstCoords ((x,y):rest) = x : firstCoords rest

-- Tuples of lists
segments = ([1,2,3], [4,5,6])
getFirstList (xs, ys) = xs
getSecondList (xs, ys) = ys


-- ============================================
-- UNARY NEGATION
-- ============================================

negate1 x = (-x)
negDouble x = (-x * 2)
negAdd x y = (-x + y)
negSubtract x y = (-x - y)
complex x = ((-x) * 2 + (-x))
doubleNeg x = (-(-x))

negateList [] = []
negateList (x:xs) = (-x) : negateList xs

processNumbers [] acc = reverse acc
processNumbers (x:xs) acc
  | x < 0     = processNumbers xs ((-x * 2) : acc)
  | x == 0    = processNumbers xs acc
  | x > 100   = processNumbers xs (div x 2 : acc)
  | otherwise = processNumbers xs ((x * x + 10) : acc)


-- ============================================
-- LAMBDA FUNCTIONS
-- ============================================

squareAll xs = map (\x -> x * x) xs
evensOnly xs = filter (\x -> mod x 2 == 0) xs
sumAll xs = fold (\acc x -> acc + x) 0 xs
productAll xs = fold (\acc x -> acc * x) 1 xs

applyTwice f x = f (f x)
applyThrice f x = f (f (f x))


-- ============================================
-- HIGHER-ORDER FUNCTIONS
-- ============================================

-- map examples
doubleMap xs = map (\x -> x * 2) xs
squareMap xs = map (\x -> x * x) xs
incrementAll xs = map (\x -> x + 1) xs

-- filter examples
bigNumbers xs = filter (\x -> x > 10) xs
smallNumbers xs = filter (\x -> x < 10) xs
evenNumbers xs = filter (\x -> mod x 2 == 0) xs
oddNumbers xs = filter (\x -> mod x 2 /= 0) xs

-- fold examples
sumFold xs = fold (\acc x -> acc + x) 0 xs
productFold xs = fold (\acc x -> acc * x) 1 xs

-- Combining functions
sumOfSquares xs = fold (\acc x -> acc + x) 0 (map (\x -> x * x) xs)
evenSquares xs = map (\x -> x * x) (filter (\x -> mod x 2 == 0) xs)


-- ============================================
-- FUNCTION COMPOSITION
-- ============================================

addOne x = x + 1
timesTwo x = x * 2
addThenDouble = timesTwo . addOne
doubleThenAdd = addOne . timesTwo

-- Multiple compositions
tripleCompose = (\x -> x + 1) . (\x -> x * 2) . (\x -> x - 3)


-- ============================================
-- PARTIAL APPLICATION (CURRYING)
-- ============================================

timesTen = multiply 10
timesFive = multiply 5
addFive = add 5
addTen = add 10


-- ============================================
-- OPERATOR SECTIONS
-- ============================================

increment = (+1)
decrement = (+(-1))
doubleIt = (*2)
halve = (/2)
square = (\x -> x * x)

isPositive = (>0)
isNegative = (<0)
isSmall = (<10)
isBig = (>100)

incrementList xs = map (+1) xs
doubleList xs = map (*2) xs
halveList xs = map (/2) xs


-- ============================================
-- LIST OPERATIONS
-- ============================================

-- Cons operator
prependOne xs = 1:xs
prependZero xs = 0:xs

-- Concatenation
joinLists xs ys = xs ++ ys
appendOne xs = xs ++ [1]

-- List indexing
firstElement xs = xs !! 0
secondElement xs = xs !! 1
thirdElement xs = xs !! 2

-- Range generation
oneToTen = [1..10]
oneToHundred = [1..100]
evens = [2,4..20]
odds = [1,3..19]
countdown = [10,9..1]


-- ============================================
-- BUILT-IN LIST FUNCTIONS
-- ============================================

getFirst xs = head xs
getRest xs = tail xs
count xs = length xs
isEmpty xs = null xs
backwards xs = reverse xs
firstThree xs = take 3 xs
skipTwo xs = drop 2 xs
firstFive xs = take 5 xs
skipTen xs = drop 10 xs


-- ============================================
-- ARITHMETIC & COMPARISON
-- ============================================

quotient x y = div x y
remainder x y = mod x y
formula1 x = x * x + 2*x + 1
formula2 x y = (x + y) * (x - y)

same x y = x == y
different x y = x /= y
bigger x y = x > y
smaller x y = x < y
atLeast x y = x >= y
atMost x y = x <= y

compareNums x y
  | x > y     = "greater"
  | x < y     = "less"
  | otherwise = "equal"


-- ============================================
-- BOOLEAN OPERATORS
-- ============================================

both x y = x && y
either x y = x || y
opposite x = not x
inRange x low high = x >= low && x <= high
outOfRange x low high = x < low || x > high


-- ============================================
-- CONSTANTS & VARIABLES
-- ============================================

pi = 3.14159
e = 2.71828
goldenRatio = 1.618
primes = [2,3,5,7,11,13,17,19,23,29]

circleArea r = pi * r * r
circleCircumference r = 2 * pi * r
sphereVolume r = (4/3) * pi * r * r * r


-- ============================================
-- COMPLEX REAL-WORLD EXAMPLES
-- ============================================

-- QuickSort
qsort [] = []
qsort (x:xs) = qsort (filter (\y -> y <= x) xs) ++ [x] ++ qsort (filter (\y -> y > x) xs)

-- List comprehension simulation
range start end = [start..end]
multiplesOf n limit = filter (\x -> mod x n == 0) [1..limit]

-- Average of a list
average xs = sumList xs / length xs

-- All elements satisfy predicate
all predicate [] = True
all predicate (x:xs) = predicate x && all predicate xs

-- Any element satisfies predicate
any predicate [] = False
any predicate (x:xs) = predicate x || any predicate xs

-- Zip two lists into tuples
zip [] ys = []
zip xs [] = []
zip (x:xs) (y:ys) = (x,y) : zip xs ys

-- Take while predicate is true
takeWhile predicate [] = []
takeWhile predicate (x:xs)
  | predicate x = x : takeWhile predicate xs
  | otherwise   = []

-- Drop while predicate is true
dropWhile predicate [] = []
dropWhile predicate (x:xs)
  | predicate x = dropWhile predicate xs
  | otherwise   = x:xs

-- Find element in list
elem x [] = False
elem x (y:ys)
  | x == y    = True
  | otherwise = elem x ys

-- Count occurrences
countOccurrences x [] = 0
countOccurrences x (y:ys)
  | x == y    = 1 + countOccurrences x ys
  | otherwise = countOccurrences x ys

-- Remove duplicates
unique [] = []
unique (x:xs) = x : unique (filter (\y -> y /= x) xs)

-- Flatten list of lists
flatten [] = []
flatten (x:xs) = x ++ flatten xs

-- Matrix operations with tuples
addVectors (x1, y1) (x2, y2) = (x1+x2, y1+y2)
dotProduct (x1, y1) (x2, y2) = x1*x2 + y1*y2
scaleVector k (x, y) = (k*x, k*y)


-- ============================================
-- TESTS - Try these in the REPL:
-- ============================================
-- double 5
-- factorial 6
-- absolute (-7)
-- myLength [1,2,3,4,5]
-- point
-- fst (10, 20)
-- sumPairs [(1,2), (3,4), (5,6)]
-- negate1 5
-- squareAll [1,2,3,4]
-- evensOnly [1,2,3,4,5,6,7,8]
-- addThenDouble 5
-- timesTen 7
-- increment 9
-- oneToTen
-- qsort [3,1,4,1,5,9,2,6]
-- zip [1,2,3] ["a","b","c"]
-- unique [1,2,2,3,3,3,4]
